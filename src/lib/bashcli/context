#!/usr/bin/env bash
# shellcheck disable=SC2034

declare -g -A BASHCLI_CONTEXT_DESCRIPTIONS=()
declare -g -A BASHCLI_CONTEXT_OPTIONS=()
declare -g -A BASHCLI_CONTEXT_OPTION_DESCRIPTIONS=()
declare -g -A BASHCLI_CONTEXT_OPTION_ALIASES=()
declare -g -A BASHCLI_CONTEXT_OPTION_VALUE_TYPES=()
declare -g -A BASHCLI_CONTEXT_OPTIONS_SOURCE=()
declare -g -A BASHCLI_CONTEXT_READ_CACHE=()

declare -g -a BASHCLI_CONTEXT_DEFAULT_OPTIONS=(help)
declare -g -r BASHCLI_CONTEXT_NOT_DOCUMENTED='Not documented.'

bashcli-context-clear() {
  BASHCLI_CONTEXT_DESCRIPTIONS=()
  BASHCLI_CONTEXT_OPTIONS=()
  BASHCLI_CONTEXT_OPTION_DESCRIPTIONS=()
  BASHCLI_CONTEXT_OPTION_ALIASES=()
  BASHCLI_CONTEXT_OPTION_VALUE_TYPES=()
  BASHCLI_CONTEXT_OPTIONS_SOURCE=()
  BASHCLI_CONTEXT_READ_CACHE=()
  bashcli-debug "context cleared"
}

bashcli-context-read() {
  local -A OPTIONS OPTION_DESCRIPTIONS OPTION_ALIASES OPTION_VALUE_TYPES
  local DESCRIPTION index commandRoot commandMain commandContext

  bashcli-command-resolve "$@"
  commandMain=${REPLY}
  commandContext=${commandMain}.context

  if [ "${BASHCLI_CONTEXT_READ_CACHE[${commandContext}]}" ]; then
    return
  fi

  if [ -f "${commandContext}" ]; then
    bashcli-debug "${commandContext}"
    DESCRIPTION=
    OPTIONS=()
    OPTION_DESCRIPTIONS=()
    OPTION_ALIASES=()
    OPTION_VALUE_TYPES=()
    . "${commandContext}"
    bashcli-context-validate
    bashcli-context-defaults
    bashcli-context-merge "${commandMain}"
    BASHCLI_CONTEXT_READ_CACHE[${commandMain}]=1
  fi
}

bashcli-context-merge() {
  local key commandMain=$1

  if [ "${DESCRIPTION}" ]; then
    BASHCLI_CONTEXT_DESCRIPTIONS[${commandMain}]=${DESCRIPTION}
  fi

  for key in "${!OPTIONS[@]}"; do
    BASHCLI_CONTEXT_OPTIONS[${key}]=${OPTIONS[${key}]}
    BASHCLI_CONTEXT_OPTIONS_SOURCE[${key}]=${commandMain}
  done

  for key in "${!OPTION_DESCRIPTIONS[@]}"; do
    BASHCLI_CONTEXT_OPTION_DESCRIPTIONS[${key}]=${OPTION_DESCRIPTIONS[${key}]}
  done

  for key in "${!OPTION_VALUE_TYPES[@]}"; do
    BASHCLI_CONTEXT_OPTION_VALUE_TYPES[${key}]=${OPTION_VALUE_TYPES[${key}]}
  done

  for key in "${!OPTION_ALIASES[@]}"; do
    BASHCLI_CONTEXT_OPTION_ALIASES[${key}]=${OPTION_ALIASES[${key}]}
  done
}

bashcli-context-defaults() {
  if [ -z "${OPTIONS[help]}" ]; then
    OPTIONS[help]=boolean
    OPTION_DESCRIPTIONS[help]="Shows a help message."
  fi
}

bashcli-context-validate() {
  local option optionType alias IFS

  for option in "${!OPTIONS[@]}"; do
    if [[ ${option} == -* ]]; then
      bashcli-fatal "Option name must not start with a dash: ${option}"
    fi
    optionType=${OPTIONS[${option}]}
    case ${optionType} in
      boolean|single|multi) ;;
      enum:?*)
        case ${OPTIONS[${optionType#enum:}]} in
          multi|boolean|enum:*)
            bashcli-fatal "Enum option-value must be a single option: ${optionType:#enum:}" ;;
        esac ;;
      *) bashcli-fatal "Option-type must be one of boolean, single, multi or enum:\${name}: ${optionType}" ;;
    esac
    if [ -z "${OPTION_DESCRIPTIONS[${option}]}" ]; then
      OPTION_DESCRIPTIONS[${option}]="${BASHCLI_CONTEXT_NOT_DOCUMENTED}"
    fi
  done

  for option in "${!OPTION_DESCRIPTIONS[@]}"; do
    if [ -z "${OPTIONS[${option}]}" ]; then
      bashcli-warn "Description for non-existing option provided: ${option}"
      unset "OPTION_DESCRIPTIONS[${option}]"
    fi
  done

  for alias in "${!OPTION_ALIASES[@]}"; do
    option=${OPTION_ALIASES[${alias}]}
    if [ -z "${OPTIONS[${option}]}" ]; then
      bashcli-warn "Alias for non-existing option provided: ${alias} -> ${option}"
      unset "OPTION_ALIASES[${option}]"
    fi
  done

  for alias in "${!OPTION_ALIASES[@]}"; do
    if [[ ${alias} == -* ]]; then
      bashcli-fatal "Alias name must not start with a dash: ${alias}"
    fi
  done
}

#!/usr/bin/env bash

bashcli-completion-complete() {
  # shellcheck disable=SC2034
  local cur prev words cword comp_args
  local -A BASHCLI_COMPLETIONS=()
  local commandStack=(.)
  local index option word subcommand completion completionFn valueType
  local parameterIndex=-1

  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  fi

  if type _comp_initialize >/dev/null 2>&1 ; then
    # bash-completion >= 2.12
    _comp_initialize -s -- "$@" || return
  elif type _init_completion >/dev/null 2>&1; then
    # bash-completion < 2.12
    _init_completion -s -- "$@" || return
  else
    bashcli-error "bash-completion is not available or could not be loaded"
    return 1
  fi

  bashcli-debug "completing ${words[*]}"
  bashcli-context-clear
  bashcli-context-read .
  bashcli-completion-read .

  for ((index = 1; index <= cword; ++index)); do
    word=${words[index]}
    option=
    case ${word} in
      --?*)
        option=${word#--}
        option=${option%%=*}
        if [ "${BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}" ]; then
          option=${BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}
        fi
        if [[ ${index} -lt ${cword} ]]; then
          if [[ ${word} == *=* ]]; then
            option=
          else
            case ${BASHCLI_CONTEXT_OPTIONS[${option}]} in
              single|multi) ((++index)) ;;
              *) option=
            esac
          fi
        elif [[ ${word} != *=* ]]; then
          option=
        fi
        ;;
      -[^-]*)
        local options=${word#-}
        local optionsIndex
        for ((optionsIndex = 0; optionsIndex < ${#options}; ++optionsIndex)); do
          option="${options:${optionsIndex}:1}"
          if [ "${BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}" ]; then
            option=${BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}
          fi
          case ${BASHCLI_CONTEXT_OPTIONS[${option}]} in
            single|multi)
              if [[ ${optionsIndex} -eq $((${#options} - 1)) ]]; then
                ((++index))
              else
                option=
              fi
              break ;;
          esac
          option=
        done ;;
      *?*)
        if [ "${word}" != -- ]; then
          ((++parameterIndex)) || true
        fi
        if bashcli-command-resolve "${commandStack[@]}" "${word}" &>/dev/null; then
          local commandMain=${REPLY}
          commandStack+=("${word}")
          bashcli-context-read "${commandStack[@]}"
          bashcli-completion-read "${commandStack[@]}"
          parameterIndex=-1
        fi ;;
      *)
        ((++parameterIndex)) || true ;;

    esac
  done

  if [ "${option}" ] && [ "${BASHCLI_CONTEXT_OPTION_VALUE_TYPES[${option}]}" ]; then
    bashcli-debug "completing value for option ${option}"
    valueType=${BASHCLI_CONTEXT_OPTION_VALUE_TYPES[${option}]}
  elif [ -z "${option}" ] && [[ "${cur}" != -* ]] && [ "${BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter-${parameterIndex}]}" ]; then
    bashcli-debug "completing parameter-${parameterIndex} value"
    valueType=${BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter-${parameterIndex}]}
  elif [ -z "${option}" ] && [[ "${cur}" != -* ]] && [ "${BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter]}" ]; then
    bashcli-debug "completing parameter value"
    valueType=${BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter]}
  elif [ "${option}" ]; then
    bashcli-debug "completing with file fallback"
    valueType=file
  elif [[ "${cur}" == -* ]]; then
    bashcli-debug "completing long options"
    for option in "${!BASHCLI_CONTEXT_OPTIONS[@]}"; do
      if [ ${#option} -gt 1 ]; then
        local suffix=
        case ${BASHCLI_CONTEXT_OPTIONS[${option}]} in
          single|multi) suffix='=' ;;
        esac
        BASHCLI_COMPLETIONS[--${option}${suffix}]=${BASHCLI_CONTEXT_OPTION_DESCRIPTIONS[${option}]}
      fi
    done
  else
    bashcli-debug "completing subcommands"
    if bashcli-command-subcommands "${commandStack[@]}"; then
      for subcommand in "${REPLY[@]}"; do
        if bashcli-command-resolve "${commandStack[@]}" "${subcommand}"; then
          local commandMain=${REPLY}
          bashcli-context-read "${commandStack[@]}" "${subcommand}" || continue
          completion=${BASHCLI_CONTEXT_DESCRIPTIONS[${commandMain}]}
          bashcli-string-trim completion
          BASHCLI_COMPLETIONS["${subcommand}"]=${completion%%$'\n'*}
        fi
      done
    else
      bashcli-debug "completing with file fallback (no subcommands)"
      valueType=file
    fi
  fi

  if [ "${valueType}" ]; then
    completionFn=${valueType//*/bashcli-complete-&}
    bashcli-debug "completionFn: ${completionFn}"
    if declare -pf "${completionFn}" &>/dev/null; then
      "${completionFn}" "${cur}"
    else
      bashcli-warn "Completion function ${completionFn} not defined"
    fi
  fi

  COMPREPLY=()
  _comp_compgen -- -W '"${!BASHCLI_COMPLETIONS[@]}"'
  case ${COMP_TYPE} in
    9|37) ;;
    *)
      if [ ${#COMPREPLY[@]} -gt 1 ]; then
        local padding=0
        for completion in "${COMPREPLY[@]}"; do
          if [[ ${#completion} -gt ${padding} ]]; then
            padding=${#completion}
          fi
        done
        for index in "${!COMPREPLY[@]}"; do
          completion=${COMPREPLY[index]}
          printf -v completion "%-${padding}s  %s    " "${completion}" "${BASHCLI_COMPLETIONS[${completion}]}"
          COMPREPLY[index]="${completion}"
        done
      elif [[ "${COMPREPLY[0]}" != *= ]]; then
        COMPREPLY[0]+=' '
      fi ;;
  esac

  for  completion in "${COMPREPLY[@]}"; do
    printf "%s\n" "${completion%%$'\n'*}"
  done
}

bashcli-completion-script() {
  local cliName=${BASHCLI_CLI_NAME}

  cat <<EOF
_${cliName}_complete() {
  readarray -t COMPREPLY < <(
    BASHCLI_DIR="${BASHCLI_DIR}"
    BASHCLI_CLI_SCRIPT="${BASHCLI_CLI_SCRIPT}"
    BASHCLI_CLI_DIR="${BASHCLI_CLI_DIR}"
    BASHCLI_CLI_NAME="${BASHCLI_CLI_NAME}"
    IFS=$'\n'

    "${BASHCLI_CLI_SCRIPT}" \\
      cli complete \\
      --comp-cword "\${COMP_CWORD}"    \\
      --comp-line  "\${COMP_LINE}"     \\
      --comp-point "\${COMP_POINT}"    \\
      --comp-type  "\${COMP_TYPE}"     \\
      --comp-words "\${COMP_WORDS[*]}" \\
      -- \\
      "\$@"
  )
} && complete -o nospace -o default -F _${cliName}_complete ${cliName}
EOF
}

bashcli-completion-read() {
  local commandMain commandComplete

  bashcli-command-resolve "$@" || return 1
  commandMain=${REPLY}
  commandComplete=${commandMain}.complete

  if [ -f "${commandComplete}" ]; then
    bashcli-debug "${commandMain} -> ${commandComplete}"
    . "${commandComplete}"
  fi
}

#!/usr/bin/env bash
# shellcheck disable=SC2034

-bashcli-completion-complete() {
  local cur prev words cword comp_args
  local -A BASHCLI_COMPLETIONS=()
  local commandStack=(.)
  local index option word completion description completionFn valueType cliPrefix
  local parameterIndex=-1
  local IFS

  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  fi

  if type _comp_initialize >/dev/null 2>&1 ; then
    # bash-completion >= 2.12
    _comp_initialize -s -n "><=;|&(:" -- "$@" || return
  elif type _init_completion >/dev/null 2>&1; then
    # bash-completion < 2.12
    _init_completion -s -n "><=;|&(:" -- "$@" || return
  else
    bashcli-error "bash-completion is not available or could not be loaded"
    return 1
  fi

  bashcli-debug "completing ${words[*]}"
  -bashcli-context-clear
  -bashcli-context-read .
  -bashcli-completion-read .

  # Parse the command line.
  for ((index = 1; index <= cword; ++index)); do
    word=${words[index]}
    option=
    case ${word} in
      --?*)
        option=${word#--}
        option=${option%%=*}
        if [ "${_BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}" ]; then
          option=${_BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}
        fi
        if [[ ${index} -lt ${cword} ]]; then
          if [[ ${word} == *=* ]]; then
            option=
          else
            case ${_BASHCLI_CONTEXT_OPTIONS[${option}]} in
              single|multi|multi-list) ((++index)) ;;
              *) option=
            esac
          fi
        elif [[ ${word} != *=* ]]; then
          option=
        fi
        ;;
      -[^-]*)
        local options=${word#-}
        local optionsIndex
        for ((optionsIndex = 0; optionsIndex < ${#options}; ++optionsIndex)); do
          option="${options:${optionsIndex}:1}"
          if [ "${_BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}" ]; then
            option=${_BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}
          fi
          case ${_BASHCLI_CONTEXT_OPTIONS[${option}]} in
            single|multi|multi-list)
              if [[ ${optionsIndex} -eq $((${#options} - 1)) ]]; then
                ((++index))
              else
                option=
              fi
              break ;;
          esac
          option=
        done ;;
      *?*)
        if [ "${word}" != -- ]; then
          ((++parameterIndex)) || true
        fi
        if -bashcli-command-resolve "${commandStack[@]}" "${word}" &>/dev/null; then
          local commandMain=${REPLY}
          commandStack+=("${word}")
          -bashcli-context-read "${commandStack[@]}"
          -bashcli-completion-read "${commandStack[@]}"
          parameterIndex=-1
        fi ;;
      *)
        ((++parameterIndex)) || true ;;

    esac
  done

  # Determine the type of completion.
  if [ "${option}" ] && [ "${_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[${option}]}" ]; then
    bashcli-debug "completing value for option ${option}"
    valueType=${_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[${option}]}
  elif [ -z "${option}" ] && [[ "${cur}" != -* ]] && [ "${_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter-${parameterIndex}]}" ]; then
    bashcli-debug "completing parameter-${parameterIndex} value"
    valueType=${_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter-${parameterIndex}]}
  elif [ -z "${option}" ] && [[ "${cur}" != -* ]] && [ "${_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter]}" ]; then
    bashcli-debug "completing parameter value"
    valueType=${_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter]}
  elif [ "${option}" ]; then
    bashcli-debug "completing with file fallback"
    valueType='file'
  elif [[ "${cur}" == -* ]]; then
    bashcli-debug "completing long options"
    for option in "${!_BASHCLI_CONTEXT_OPTIONS[@]}"; do
      if [ ${#option} -gt 1 ]; then
        local alias aliases=() suffix=
        case ${_BASHCLI_CONTEXT_OPTIONS[${option}]} in
          single|multi|multi-list) suffix='=' ;;
        esac
        description=${_BASHCLI_CONTEXT_OPTION_DESCRIPTIONS[${option}]}
        bashcli-string-trim description
        description=${description%%$'\n'}
        for alias in "${!_BASHCLI_CONTEXT_OPTION_ALIASES[@]}"; do
          if [ ${#alias} == 1 ] && [ "${option}" == "${_BASHCLI_CONTEXT_OPTION_ALIASES[${alias}]}" ]; then
            aliases+=("-${alias}")
          fi
        done
        if [ "${aliases}" ]; then
          IFS=$'\n'
          readarray -t aliases <<<"$(LC_ALL=C sort <<<"${aliases[*]}")"
          IFS=,
          description+=" (${aliases[*]})"
          unset IFS
        fi
        BASHCLI_COMPLETIONS[--${option}${suffix}]=${description}
      fi
    done
  else
    if bashcli-complete-subcommand "${commandStack[@]}"; then
      bashcli-debug "completing subcommands"
    else
      bashcli-debug "completing file fallback"
      valueType=file
    fi
  fi

  # Find a completion function and invoke it.
  if [ "${valueType}" ]; then
    for cliPrefix in "${BASHCLI_CLI_NAME}" bashcli; do
      completionFn=${cliPrefix}-complete-${valueType}
      if declare -pf "${completionFn}" &>/dev/null; then
        COMPREPLY=()
        local BASHCLI_COMPLETION_OPTION=${option}
        local BASHCLI_COMPLETION_OPTION_TYPE=${option:+${_BASHCLI_CONTEXT_OPTIONS[${option}]}}
        local BASHCLI_COMPLETION_VALUE_TYPE=${valueType}
        local BASHCLI_COMPLETION_PARAMETER_INDEX=${parameterIndex}
        bashcli-debug "fn -> ${completionFn}"
        "${completionFn}" >/dev/null
        if ((${#COMPREPLY[@]})); then
          for completion in "${COMPREPLY[@]}"; do
            BASHCLI_COMPLETIONS[${completion}]=''
          done
        fi
        break
      elif [ "${cliPrefix}" == bashcli ]; then
        bashcli-warn "Completion function ${completionFn} not defined"
      fi
    done
  fi

  # Create the array with bare completions.
  COMPREPLY=()
  if declare -pf _comp_delimited &>/dev/null && [ "${BASHCLI_COMPLETION_OPTION_TYPE}" == multi-list ]; then
    _comp_delimited , -W '"${!BASHCLI_COMPLETIONS[@]}"' || true
  elif declare -pf _comp_compgen &>/dev/null; then
    _comp_compgen -- -W '"${!BASHCLI_COMPLETIONS[@]}"' || true
  else
    COMPREPLY=($(compgen -W '"${!BASHCLI_COMPLETIONS[@]}"' -- "${cur}"))
  fi

  # Postprocess the completions.
  case ${#COMPREPLY[@]} in
    0) ;;
    1) local multiListOptions=${cur//[^,]/},
       if [ "${BASHCLI_COMPLETION_OPTION_TYPE}" == multi-list ] && [ ${#multiListOptions} -lt ${#BASHCLI_COMPLETIONS[@]} ]; then
         if [ "${cur}" == "${COMPREPLY[0]}" ]; then
           COMPREPLY=("${cur},")
         fi
       elif [[ "${COMPREPLY[0]}" != *= ]]; then
         COMPREPLY[0]+=' '
       fi
       ;;
    *)
      case ${COMP_TYPE} in
        9|37)
        # Special completion-modes which are not compatible with listing descriptions.
        ;;
        *)
          # List completions with their descriptions.
          local padding=0
          for completion in "${COMPREPLY[@]}"; do
            if [[ ${#completion} -gt ${padding} ]]; then
              padding=${#completion}
            fi
          done
          for index in "${!COMPREPLY[@]}"; do
            completion=${COMPREPLY[index]}
            printf -v completion "%-${padding}s  %s    " "${completion}" "${BASHCLI_COMPLETIONS[${completion}]}"
            COMPREPLY[index]="${completion}"
          done
          ;;
      esac
  esac

  if [[ ${cur} == *:* && ${COMP_WORDBREAKS} == *:* ]]; then
    # Remove colon-word prefix from items in COMPREPLY
    local colonWord=${cur%"${cur##*:}"}
    COMPREPLY=("${COMPREPLY[@]#"${colonWord}"}")
  fi

  # Print the completions for the -bashcli-completion-script function to pickup.
  for completion in "${COMPREPLY[@]}"; do
    printf "%s\n" "${completion%%$'\n'*}"
  done
}

-bashcli-completion-script() {
  local cliName=${BASHCLI_CLI_NAME}

  cat <<EOF
_${cliName}_complete() {
  readarray -t COMPREPLY < <(
    IFS=$'\n'

    "${BASHCLI_CLI_SCRIPT}" \\
      cli completion \\
      --comp-cword "\${COMP_CWORD}"    \\
      --comp-line  "\${COMP_LINE}"     \\
      --comp-point "\${COMP_POINT}"    \\
      --comp-type  "\${COMP_TYPE}"     \\
      --comp-words "\${COMP_WORDS[*]}" \\
      -- \\
      "\$@"
  )
} && complete -o nospace -o default -F _${cliName}_complete ${cliName}
EOF
}

-bashcli-completion-read() {
  local commandMain commandComplete

  -bashcli-command-resolve "$@" || return 1
  commandMain=${REPLY}
  commandComplete=${commandMain}.complete

  if [ -f "${commandComplete}" ]; then
    bashcli-debug "${commandMain} -> ${commandComplete}"
    . "${commandComplete}"
  fi
}

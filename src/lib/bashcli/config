#!/usr/bin/env bash

declare -g BASHCLI_CONFIG_GLOBAL_DIR=${BASHCLI_CONFIG_GLOBAL_DIR:-${XDG_CONFIG_HOME:-${HOME}/.config}/${BASHCLI_CLI_NAME}}
declare -g BASHCLI_CONFIG_LOCAL_DIR=${BASHCLI_CONFIG_LOCAL_DIR}
declare -g BASHCLI_CONFIG_DEFAULT_DIR=${BASHCLI_CONFIG_DEFAULT_DIR:-${BASHCLI_CLI_DIR}/config}

declare -g _BASHCLI_CONFIG_PROPERTY_PATTERN='+([a-zA-Z0-9._-])'
declare -g _BASHCLI_CONFIG_PROFILE_PATTERN='+([a-zA-Z0-9-])'

declare -g _BASHCLI_CONFIG_MAX_EVAL_DEPTH=${_BASHCLI_CONFIG_MAX_EVAL_DEPTH:-16}
declare -g _BASHCLI_CONFIG_EVAL_DEPTH=0

declare -g -A _BASHCLI_CONFIG_PROPERTIES=()
declare -g -A _BASHCLI_CONFIG_PROPERTIES_PROFILE=()

declare -g    BASHCLI_CONFIG_PROFILES=()
declare -g -A _BASHCLI_CONFIG_PROFILE_PRIORITIES=()

declare -g -A _BASHCLI_CONFIG_ENV=()
declare -g _BASHCLI_CONFIG_DIR_NAME=config
declare -g _BASHCLI_CONFIG_FILE_EXTENSION=conf

bashcli-config-initialize() {
  local IFS=,
  bashcli-debug "initializing with profiles [$*]"
  unset IFS
  _BASHCLI_CONFIG_PROPERTIES=()
  _BASHCLI_CONFIG_PROPERTIES_PROFILE=()
  -bashcli-config-initialize-profiles "$@"
  -bashcli-config-initialize-env
}

bashcli-config-clear() {
  if [ $# -ne 0 ]; then
    bashcli-error "no arguments expected"
    return 1
  fi
  bashcli-config-initialize "${BASHCLI_CONFIG_PROFILES[@]}"
}

bashcli-config-read() {
  local configFiles=()
  local namespace=options
  local OPTIND=1
  local scopes=all
  local option prefixes configFile

  while getopts ":s:n:f:p:" option "$@"; do
    case ${option} in
      s) scopes=${OPTARG};;
      n) -bashcli-config-check-namespace "${OPTARG}"
         namespace=${OPTARG};;
      f) if [ "${OPTARG}" ]; then
           configFiles+=("${OPTARG}")
         fi;;
      p) if [ "${OPTARG}" ]; then
           -bashcli-config-check-property "${OPTARG}"
           prefixes+=("${OPTARG}")
         fi;;
      :) bashcli-error "option requires an argument: ${OPTARG}"
         return 1;;
      *) bashcli-error "option not recognized: ${OPTARG}"
         return 1;;
    esac
  done

  if [ ${OPTIND} -le $# ]; then
    bashcli-error "too many arguments: $*"
    return 1
  fi

  if [ "${scopes}" ] && [ ${#configFiles[@]} -eq 0 ]; then
    bashcli-config-files "${scopes}" "${namespace}"
    configFiles=("${REPLY[@]}")
  fi

  bashcli-debug "reading with namespace=${namespace} scopes=${scopes} #files=${#configFiles[@]}"

  for configFile in "${configFiles[@]}"; do
    if [ -f "${configFile}" ]; then
      -bashcli-config-read-file "${configFile}" "${namespace}" "${prefixes[@]}"
    else
      bashcli-debug "skipping non-regular or missing file: ${configFile}"
    fi
  done
}

bashcli-config-files() {
  local forWrite
  if [ "$1" == -w ]; then
    forWrite=true
    shift
  fi
  local namespace=${2:-options}
  local filename=${_BASHCLI_CONFIG_DIR_NAME}/${namespace}.${_BASHCLI_CONFIG_FILE_EXTENSION}
  local scope scopes

  bashcli-resource-scopes-parse "${1-all}"
  scopes=("${REPLY[@]}")
  REPLY=()

  for scope in "${scopes[@]}"; do
    if [ "${forWrite}" ]; then
      case ${scope} in
        builtin|default)
          bashcli-error "builtin and default scopes are read-only"
          return 1;;
        esac
    fi
    REPLY+=("${BASHCLI_RESOURCE_SCOPES_DIRS[${scope}]}/${filename}")
  done
}

-bashcli-config-read-file() {
  local configFile=$1
  local namespace=$2
  shift 2
  local prefixes=("$@")
  local lineNumber=1
  local pattern=.
  local index line property qualifiedProperty
  local value profile priority propertyProfile currentPriority

  bashcli-debug "reading ${configFile}"

  if [ ${#prefixes[@]} -gt 0 ]; then
    bashcli-array-join prefixes '|'
    printf -v pattern "^[[:space:]]*(%%[a-zA-Z0-9-]+\\.)?(%s)\\." "${REPLY}"
  fi

  while IFS= read -r line || [ -n "${line}" ]; do
    if -bashcli-config-read-line "${line}" "${configFile}" "${lineNumber}"; then
      profile=${REPLY[0]}
      property=${namespace}.${REPLY[1]}
      value=${REPLY[2]}
      propertyProfile=${_BASHCLI_CONFIG_PROPERTIES_PROFILE[${property}]}

      if [ -z "${_BASHCLI_CONFIG_PROFILE_PRIORITIES[${profile}]}" ]; then
        # Profile is not active.
        continue
      elif [ "${propertyProfile}" ]; then
        # Property already set, check profile priorities.
        priority=${_BASHCLI_CONFIG_PROFILE_PRIORITIES[${profile}]}
        currentPriority=${_BASHCLI_CONFIG_PROFILE_PRIORITIES[${propertyProfile}]}

        if [ "${priority}" -lt "${currentPriority}" ]; then
          continue
        fi
      fi

      _BASHCLI_CONFIG_PROPERTIES[${property}]=${value}
      _BASHCLI_CONFIG_PROPERTIES_PROFILE[${property}]=${profile}
      if [ "${BASHCLI_DEBUG}" ]; then
        bashcli-debug "%${profile}.${property}=${value}"
      fi
    fi
    ((++lineNumber))
  done < <(grep -E "${pattern}" "${configFile}")
}

bashcli-config-get() {
  local property qualifiedProperty profile value type
  local failIfUnset isSet
  local OPTIND=1
  local namespace=options

  REPLY=
  while getopts ":t:n:x" option "$@"; do
    case ${option} in
      t) type=${OPTARG};;
      n) -bashcli-config-check-namespace "${OPTARG}"
         namespace=${OPTARG};;
      x) failIfUnset=true;;
      :) bashcli-error "option requires an argument: ${OPTARG}"
         return 1;;
      *) bashcli-error "option not recognized: ${OPTARG}"
         return 1;;
    esac
  done
  shift "$((OPTIND - 1))"

  if [ $# -ne 1 ]; then
    bashcli-error "too many arguments"
    return 1
  fi

  property=$1
  qualifiedProperty=${namespace}.${property}
  -bashcli-config-check-property "${property}"
  profile=${_BASHCLI_CONFIG_PROPERTIES_PROFILE[${qualifiedProperty}]}

  if -bashcli-config-env-get "${namespace}" "${profile:-default}" "${property}"; then
    value=${REPLY}
    isSet=true
  elif [ "${profile}" ]; then
    value=${_BASHCLI_CONFIG_PROPERTIES[${qualifiedProperty}]}
    isSet=true
  fi

  if [ "${isSet}" ]; then
    -bashcli-config-eval "${namespace}" "${value}"
  fi

  if [ "${BASHCLI_DEBUG}" ]; then
    if [ "${isSet}" ]; then
      bashcli-debug "${profile:-default} ${property} ${REPLY}"
    else
      bashcli-debug "${profile:-default} ${property} <unset>"
    fi
  fi

  if [ "${type}" ]; then
    -bashcli-config-coerce-value "${REPLY}" "${type}"
  fi

  [ "${isSet}" ] || [ -z "${failIfUnset}" ]
}

-bashcli-config-coerce-value() {
  local value=$1
  local type=$2
  local array

  case ${type} in
    array)
      REPLY=()
      bashcli-string-split "${value}" , array
      for value in "${array[@]}"; do
        bashcli-string-trim value
        REPLY+=("${value}")
      done;;
    boolean)
      case ${value} in
        true) REPLY=true;;
        *) REPLY=false;;
      esac;;
    *)
      bashcli-error "type not supported: ${type}"
      return 1;;
  esac
}

bashcli-config-get-properties() {
  local OPTIND=1
  local namespace=${BASHCLI_CLI_NAME}
  local property propertyNoNamespace option

  REPLY=()
  while getopts "n:" option "$@"; do
    case ${option} in
      n) -bashcli-config-check-namespace "${OPTARG}"
         namespace=${OPTARG};;
      *) return 1;;
    esac
  done

  shift "$((OPTIND - 1))"
  if [ $# -ne 0 ]; then
    bashcli-error "too many arguments"
    return 1
  fi

  for property in "${!_BASHCLI_CONFIG_PROPERTIES[@]}"; do
    if [[ "${property}" == "${namespace}".* ]]; then
      propertyNoNamespace=${property:$((${#namespace} + 1))}
      REPLY+=("${propertyNoNamespace}")
    fi
  done
}

bashcli-config-write() {
  local updateMode=set
  local namespace=options
  local scopes=global
  local profile=default
  local configFiles=()
  local option configFile property value

  while getopts ":s:n:f:P:U" option "$@"; do
    case ${option} in
      s) scopes=${OPTARG};;
      n) -bashcli-config-check-namespace "${OPTARG}"
         namespace=${OPTARG};;
      f) if [ "${OPTARG}" ]; then
           configFiles+=("${OPTARG}")
         fi;;
      U) updateMode=unset;;
      P) -bashcli-config-check-profile "${OPTARG}"
         profile="${OPTARG}";;
      :) bashcli-error "option requires an argument: ${OPTARG}"
         return 1;;
      *) bashcli-error "option not recognized: ${OPTARG}"
         return 1;;
    esac
  done

  shift "$((OPTIND - 1))"

  case ${updateMode}/$# in
    set/2);;
    unset/1);;
    set/*) bashcli-error "property and value arguments expected: $*"
           return 1;;
    unset/*) bashcli-error "property argument expected: $*"
             return 1;;
    *) bashcli-fatal "internal error";;
  esac

  property=$1
  value=$2
  bashcli-string-trim property
  bashcli-string-trim value
  -bashcli-config-check-property "${property}"

  if [ "${scopes}" ] && [ ${#configFiles[@]} -eq 0 ]; then
    bashcli-config-files -w "${scopes}" "${namespace}"
    configFiles=("${REPLY[@]}")
  fi

  if [ ${#configFiles[@]} -ne 1 ]; then
    bashcli-error "require a single scope or config-file when updating properties"
    return 1
  fi
  configFile=${configFiles[0]}
  case "${configFile}" in
    "${BASHCLI_RESOURCE_SCOPES_DIRS[default]}"|"${BASHCLI_RESOURCE_SCOPES_DIRS[builtin]}")
      bashcli-error "default and builtin scopes are read-only" ;;
  esac

  bashcli-debug "${updateMode}" "${configFile}" "${profile}" "${property}" "${value}"
  -bashcli-config-write-value "${updateMode}" "${configFile}" "${profile}" "${property}" "${value}"
}

-bashcli-config-write-value() {
  local updateMode=$1
  local configFile=$2
  local profile=$3
  local property=$4
  local value=$5
  local profilePrefix
  local configFile
  local tempFile=$(mktemp)
  local updated=

  trap 'rm -f -- "${tempFile}"' RETURN

  -bashcli-config-escape value

  if [ "${profile}" != default ]; then
    profilePrefix="%${profile}."
  fi

  if [ -f "${configFile}" ]; then
    while IFS= read -r line || [ -n "${line}" ]; do
      if ! -bashcli-config-read-line "${line}" "${configFile}" "${lineNumber}"; then
        printf "%s\n" "${line}"
        continue
      fi

      if [ "${profile}" == "${REPLY[0]}" ] && [ "${property}" == "${REPLY[1]}" ]; then
        # Update the value or remove it from the output, dependening on the update-mode.
        if [ "${updateMode}" == set ]; then
          updated=true
          printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}"
        fi
      else
        printf "%s\n" "${line}"
      fi
      ((++lineNumber))
    done < "${configFile}" > "${tempFile}"

    if [ "${updateMode}" == set ] && [ -z "${updated}" ]; then
      # Property was not found, append it.
      printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}" >> "${tempFile}"
    fi

    mv "${tempFile}" "${configFile}"
  elif [ -e "${configFile}" ]; then
    bashcli-error "not a regular file: ${configFile}"
    return 1
  elif [ "${updateMode}" == set ]; then
    # File does not exist yet, create it.
    mkdir --parent "$(dirname "${configFile}")"
    printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}" > "${configFile}"
  fi
}

# List all properties.
bashcli-config-list() {
  local property namespace qualifiedProperty qualifiedProperties

  if [ $# -ne 0 ]; then
    bashcli-error "no arguments expected"
    return 1
  fi

  qualifiedProperties=("${!_BASHCLI_CONFIG_PROPERTIES[@]}")
  bashcli-array-sort qualifiedProperties

  for qualifiedProperty in "${qualifiedProperties[@]}"; do
    namespace=${qualifiedProperties%%.*}
    property=${qualifiedProperty#*.}
    if bashcli-config-get -n "${namespace}" -x "${property}"; then
      -bashcli-config-escape REPLY
      printf "%s=%s\n" "${property}" "${REPLY}"
    fi
  done
}

-bashcli-config-eval() {
  local namespace=$1
  local initialValue=$2
  local value=${initialValue}
  local result prefix expr exprValue property qualifiedProperty default
  REPLY=

  if [[ "${value}" != *[\$\\]* ]]; then
    REPLY=${value}
    return 0
  fi

  if [ ${_BASHCLI_CONFIG_EVAL_DEPTH} -gt "${_BASHCLI_CONFIG_MAX_EVAL_DEPTH}" ]; then
    bashcli-fatal "apparent cyclic property dependencies found during evaluation"
  fi

  trap "((--_BASHCLI_CONFIG_EVAL_DEPTH)) || true" RETURN
  ((++_BASHCLI_CONFIG_EVAL_DEPTH))

  while [ "${value}" ]; do
    prefix=${value%%[\$\\]*}
    value=${value:${#prefix}}
    result+=${prefix}

    case ${value:0:1} in
      \\) case ${value:1:1} in
            n) result+=$'\n';;
            r) result+=$'\r';;
            t) result+=$'\t';;
            s) result+=' ';;
            *) result+=${value:1:1};;
          esac
          value=${value:2};;
      \$) if [ "${value:1:1}" != '{' ]; then
            result+='$'
            value=${value:1}
          else
            value=${value:2}
            expr=${value%%\}*}
            value=${value:${#expr}}
            value=${value:1}
            property=${expr%%\:*}
            default=${expr:$((${#property} + 1))}
            qualifiedProperty=${namespace}.${property}
            if [ "${_BASHCLI_CONFIG_PROPERTIES_PROFILE[${qualifiedProperty}]}" ]; then
              exprValue=${_BASHCLI_CONFIG_PROPERTIES[${qualifiedProperty}]}
            elif [ "${_BASHCLI_CONFIG_ENV[${property}]}" ]; then
              exprValue=${!property}
            fi
            if [ -z "${exprValue}" ]; then
              exprValue=${default}
            fi
            if [ "${exprValue}" ]; then
              -bashcli-config-eval "${namespace}" "${exprValue}"
              result+=${REPLY}
            fi
          fi;;
      esac
  done

  REPLY=${result}
}

-bashcli-config-escape() {
  local -n _value=$1
  local _spaces

  _value=${_value//$'\n'/\\n}
  _value=${_value//$'\r'/\\r}
  _value=${_value//$'\t'/\\t}
  _spaces=${_value%%[^ ]*}
  _value=${_spaces//?/\\s}${_value:${#_spaces}}
  _spaces=${_value##*[^ ]}
  _value=${_value:0:$((${#_value} - ${#_spaces}))}${_spaces//?/\\s}
}

-bashcli-config-read-line() {
  local line=$1
  local configFile=$2
  local lineNumber=$3
  local profile=default
  local property value

  if [[ ${line} == *([[:space:]])?(\#*) ]]; then
    return 1
  fi

  property=${line%%=*}
  value=${line#*=}
  # inlined bashcli-string-trim for performance
  property=${property##+([ $'\t\r\n'])}
  property=${property%%+([ $'\t\r\n'])}
  value=${value##+([ $'\t\r\n'])}
  value=${value%%+([ $'\t\r\n'])}

  if [[ ${property} == %* ]]; then
    profile=${property%%.*}
    property=${property:${#profile}}
    property=${property:1}
    profile=${profile#\%}
  fi

  if [ -z "${property}" ]; then
    bashcli-warn "failed to read line ${lineNumber} of file ${configFile}"
    return 1
  fi

  # inlined -bashcli-config-check-property for performance
  if [[ ${property} != ${_BASHCLI_CONFIG_PROPERTY_PATTERN} ]]; then
    bashcli-error "invalid property name: ${property} (should match '${_BASHCLI_CONFIG_PROPERTY_PATTERN}')"
    return 1
  fi

  REPLY=("${profile}" "${property}" "${value}")
}

-bashcli-config-env-get() {
  local namespace=$1
  local profile=$2
  local property=$3
  local minPriority=${_BASHCLI_CONFIG_PROFILE_PRIORITIES[${profile}]}

  if [ -z "${minPriority}" ]; then
    bashcli-error "internal error: profile not active: ${profile}"
    return 1
  fi

  for ((index = $((${#BASHCLI_CONFIG_PROFILES[@]} - 1)); index >= ${minPriority}; --index)); do
    profile=${BASHCLI_CONFIG_PROFILES[${index}]}
    if -bashcli-config-env-read "${namespace}" "${profile}" "${property}"; then
      return 0
    fi
  done

  return 1
}

-bashcli-config-env-read() {
  local namespace=$1
  local profile=$2
  local property=$3
  local variable=${BASHCLI_CLI_NAME}_${namespace}_

  if [ "${profile}" != default ]; then
    variable="_${profile}_${variable}"
  fi
  variable+=${property}
  variable=${variable//[^a-zA-Z0-9]/_}
  variable=${variable^^}

  if [ "${_BASHCLI_CONFIG_ENV[${variable}]}" ]; then
    REPLY=${!variable}
    bashcli-debug "${property} -> ${variable} -> ${REPLY}"
    return 0
  fi

  return 1
}

-bashcli-config-initialize-profiles() {
  local profile
  local profiles=(default "$@")
  local index=0

  BASHCLI_CONFIG_PROFILES=()
  _BASHCLI_CONFIG_PROFILE_PRIORITIES=()

  # Check profile-names, remove duplicate and empty profiles, but keep the order.
  for ((index = $((${#profiles[@]})); index >= 0; --index)); do
    profile=${profiles[index]}
    if [ "${profile}" ] && [ -z "${_BASHCLI_CONFIG_PROFILE_PRIORITIES[${profile}]}" ]; then
      -bashcli-config-check-profile "${profile}"
      _BASHCLI_CONFIG_PROFILE_PRIORITIES[${profile}]=${index}
      BASHCLI_CONFIG_PROFILES=("${profile}" "${BASHCLI_CONFIG_PROFILES[@]}")
    fi
  done

  # Remove gaps from profile priorities.
  _BASHCLI_CONFIG_PROFILE_PRIORITIES=()
  for ((index = 0; index < ${#BASHCLI_CONFIG_PROFILES[@]}; ++index)); do
    profile=${BASHCLI_CONFIG_PROFILES[index]}
    _BASHCLI_CONFIG_PROFILE_PRIORITIES[${profile}]=${index}
  done
}

-bashcli-config-initialize-env() {
  local IFS line name

  if [ ${#_BASHCLI_CONFIG_ENV[@]} -gt 0 ]; then
    return 0
  fi

  while IFS= read -r line || [ -n "${line}" ]; do
    name=${line%%=*}
    _BASHCLI_CONFIG_ENV[${name}]=defined
  done < <(env)
}

-bashcli-config-check-property() {
  local property=$1
  if [[ ${property} != ${_BASHCLI_CONFIG_PROPERTY_PATTERN} ]]; then
    bashcli-error "invalid property name: ${property} (should match '${_BASHCLI_CONFIG_PROPERTY_PATTERN}')"
    return 1
  fi
}

-bashcli-config-check-profile() {
  local profile=$1
  if [[ ${profile} != ${_BASHCLI_CONFIG_PROFILE_PATTERN} ]]; then
    bashcli-error "invalid profile name: ${profile} (should match '${_BASHCLI_CONFIG_PROFILE_PATTERN}')"
    return 1
  fi
}

-bashcli-config-check-namespace() {
  local namespace=$1
  if [[ -z "${namespace}" || "${namespace}" == */* ]]; then
    bashcli-error "namespace must not be empty or contain slashes: ${namespace}"
    return 1
  fi
}

-bashcli-config-check-scope() {
  local scope=$1
  case ${scope} in
    default|global|local) ;;
    *) bashcli-error "invalid scope: ${scope} (should be one of default, local or global)"
       return 1
  esac
}

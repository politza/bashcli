#!/usr/bin/env bash

declare -g BASHCLI_CONFIG_GLOBAL=${BASHCLI_CONFIG_GLOBAL:-${XDG_CONFIG_HOME:-$HOME/.config}/${BASHCLI_CLI_NAME}/${BASHCLI_CLI_NAME}.conf}
declare -g BASHCLI_CONFIG_LOCAL=${BASHCLI_CONFIG_LOCAL}

declare -g BASHCLI_CONFIG_PROPERTY_PATTERN='+([a-zA-Z0-9._-])'
declare -g BASHCLI_CONFIG_PROFILE_PATTERN='+([a-zA-Z0-9-])'

declare -g BASHCLI_CONFIG_MAX_EVAL_DEPTH=${BASHCLI_CONFIG_MAX_EVAL_DEPTH:-16}
declare -g BASHCLI_CONFIG_EVAL_STACK=()

declare -g BASHCLI_CONFIG_INITIALIZED=

declare -g -A BASHCLI_CONFIG_PROPERTIES=()
declare -g -A BASHCLI_CONFIG_PROPERTY_PROFILE=()

declare -g BASHCLI_CONFIG_PROFILES=()
declare -g -A BASHCLI_CONFIG_PROFILE_INDEX=()
declare -g -A BASHCLI_CONFIG_KNOWN_PROFILES=()

declare -g -A BASHCLI_CONFIG_ENV=()

declare -g BASHCLI_CONFIG_SCOPE=

bashcli-config-get() {
  local property=$1

  case $# in
    0) bashcli-error "property-name parameter missing"
       return 1 ;;
    1) ;;
    *) bashcli-error "too many arguments: $*"
       return 1;;
  esac

  bashcli-config-initialize
  bashcli-config-check-property "${property}"

  if [ "${BASHCLI_CONFIG_PROPERTIES[${property}]}" ]; then
    printf "%s\n" "${BASHCLI_CONFIG_PROPERTIES[${property}]}"
  fi
}

bashcli-config-set() {
  case $# in
    0) bashcli-error "property-name parameter missing"
       return 1 ;;
    1) bashcli-error "property-value parameter missing"
       return 1 ;;
    2) ;;
    *) bashcli-error "too many arguments: $*"
       return 1 ;;
  esac

  -bashcli-config-set --unset "$@"
}

bashcli-config-unset() {
  case $# in
    0) bashcli-error "property-name parameter missing"
       return 1 ;;
    1) ;;
    *) bashcli-error "too many arguments: $*"
       return 1 ;;
  esac

  -bashcli-config-set --set "$@"
}

bashcli-config-list() {
  local IFS=$'\n'
  local property
  local properties

  if [ $# -gt 0 ]; then
    bashcli-error "too many arguments: $*"
    return 1
  fi

  bashcli-config-initialize
  properties=($(LC_ALL=C sort <<<"${!BASHCLI_CONFIG_PROPERTIES[@]}"))

  for property in "${properties[@]}"; do
    printf "%s=%s\n" "${property}" "${BASHCLI_CONFIG_PROPERTIES[${property}]}"
  done
}

bashcli-config-initialize() {
  local IFS line variableName profile

  if [ "${BASHCLI_CONFIG_INITIALIZED}" ]; then
    return
  fi
  BASHCLI_CONFIG_INITIALIZED=1

  bashcli-debug "initializing"
  -bashcli-config-initialize-profiles
  -bashcli-config-initialize-scope
  -bashcli-config-initialize-env
  -bashcli-config-read
  -bashcli-config-read-env
  -bashcli-config-eval-properties

  bashcli-debug "read ${#BASHCLI_CONFIG_PROPERTIES[@]} properties"
}

bashcli-config-reinitialize() {
  BASHCLI_CONFIG_INITIALIZED=
  bashcli-config-initialize
}

bashcli-config-file() {
  local configFile
  local scope=${BASHCLI_CONFIG_SCOPE}

  if [ -z "${scope}" ]; then
    if [ "${BASHCLI_CONFIG_LOCAL}" ]; then
      scope=local
    else
      scope=global
    fi
  fi

  case ${scope} in
    global) configFile=${BASHCLI_CONFIG_GLOBAL} ;;
    local) configFile=${BASHCLI_CONFIG_LOCAL} ;;
    *) bashcli-fatal "internal error: invalid scope: ${scope}" ;;
  esac
  if [ -z "${configFile}" ]; then
    bashcli-error "property file unset"
    return 1
  fi
  printf "%s" "${configFile}"
}

-bashcli-config-eval-properties() {
  local property

  for property in "${!BASHCLI_CONFIG_PROPERTIES[@]}"; do
    if -bashcli-config-eval "${BASHCLI_CONFIG_PROPERTIES[${property}]}"; then
      bashcli-debug "${property}=${REPLY}"
      BASHCLI_CONFIG_PROPERTIES[${property}]=$REPLY
    else
      bashcli-debug "${property}="
      BASHCLI_CONFIG_PROPERTIES[${property}]=
    fi
  done
}

-bashcli-config-eval() {
  local initialValue=$1
  local value=${initialValue}
  local result=
  local prefix expr exprValue property default
  # Using a nameref here avoids a bash quirks.
  local -n evalStack=BASHCLI_CONFIG_EVAL_STACK
  REPLY=

  if [[ "${value}" != *[\$\\]* ]]; then
    REPLY=${value}
    return
  fi

  if [ ${#evalStack[@]} -gt "${BASHCLI_CONFIG_MAX_EVAL_DEPTH}" ]; then
    bashcli-fatal "apparent cyclic property dependencies found during evaluation"
  fi

  evalStack+=("")
  trap "unset 'evalStack[-1]'" RETURN


  while [ "${value}" ]; do
    prefix=${value%%[\$\\]*}
    value=${value:${#prefix}}
    result+=${prefix}

    case ${value:0:1} in
      \\) case ${value:1:1} in
            n) result+=$'\n' ;;
            r) result+=$'\r' ;;
            t) result+=$'\t' ;;
            s) result+=' ' ;;
            *) result+=${value:1:1} ;;
          esac
          value=${value:2} ;;
      \$) if [ "${value:1:1}" != '{' ]; then
            result+='$'
            value=${value:1}
          else
            value=${value:2}
            expr=${value%%\}*}
            value=${value:${#expr}}
            value=${value:1}
            property=${expr%%\:*}
            default=${expr:$((${#property} + 1))}
            if ! bashcli-config-check-property "${property}"; then
              bashcli-error "failed to evaluate '${initialValue}'"
              return 1
            fi
            if [ "${BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]}" ]; then
              exprValue=${BASHCLI_CONFIG_PROPERTIES[${property}]}
            elif [ "${BASHCLI_CONFIG_ENV[${property}]}" ]; then
              exprValue=${!property}
            fi
            if [ -z "${exprValue}" ]; then
              exprValue=${default}
            fi
            if [ "${exprValue}" ]; then
              -bashcli-config-eval "${exprValue}"
              result+=${REPLY}
            fi
          fi
          ;;
      esac
  done

  REPLY=${result}
}

-bashcli-config-set() {
  local updateMode=$1
  local property=$2
  local value=$3
  local profile=

  if [ ${#BASHCLI_CONFIG_PROFILES[@]} -gt 0 ]; then
    profile=${BASHCLI_CONFIG_PROFILES[-1]}
  fi

  bashcli-string-trim property
  bashcli-string-trim value

  bashcli-config-check-property "${property}"
  bashcli-debug "${profile}" "${property}" "${value}"
  -bashcli-config-write-value "${updateMode}" "${profile}" "${property}" "${value}"
}

-bashcli-config-read() {
  local IFS=,
  local configFiles=()
  local configFile

  if [ -z "${BASHCLI_CONFIG_SCOPE}" ] || [ "${BASHCLI_CONFIG_SCOPE}" == global ]; then
    configFiles+=("${BASHCLI_CONFIG_GLOBAL}")
  fi

  if [ -z "${BASHCLI_CONFIG_SCOPE}" ] || [ "${BASHCLI_CONFIG_SCOPE}" == local ]; then
    configFiles+=("${BASHCLI_CONFIG_LOCAL}")
  fi

  bashcli-debug "reading in scope ${BASHCLI_CONFIG_SCOPE:-<none>} with profiles [${BASHCLI_CONFIG_PROFILES[*]}]"

  for configFile in "${configFiles[@]}"; do
    if [ -f "${configFile}" ]; then
      -bashcli-config-read-file "${configFile}"
    fi
  done
}

-bashcli-config-read-file() {
  local configFile
  local lineNumber=0
  local index line property value
  local profile priority propertyProfile currentPriority update
  local mergeMode=update

  if [ "$1" == -m ]; then
    mergeMode=$2
    shift 2
  fi
  configFile=$1
  case $mergeMode in
    keep|update) ;;
    *) bashcli-error "internal error: invalid merge-mode: ${mergeMode}"
       return 1;;
  esac

  bashcli-debug "reading ${configFile}"

  while IFS= read -r line || [ -n "${line}" ]; do
    if -bashcli-config-read-line "${line}" "${configFile}" "${lineNumber}"; then
      profile=${REPLY[0]}
      property=${REPLY[1]}
      value=${REPLY[2]}
      propertyProfile=${BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]}
      BASHCLI_CONFIG_KNOWN_PROFILES[${profile}]=1
      update=

      if [ -z "${BASHCLI_CONFIG_PROFILE_INDEX[${profile}]}" ]; then
        # Profile not activated.
        continue
      elif [ -z "${propertyProfile}" ]; then
        # Property is not yet defined.
        update=true
      else
        priority=${BASHCLI_CONFIG_PROFILE_INDEX[${profile}]}
        currentPriority=${BASHCLI_CONFIG_PROFILE_INDEX[${propertyProfile}]}

        if [ "${priority}" -gt "${currentPriority}" ]; then
          update=true
        elif [ "${priority}" -eq "${currentPriority}" ]; then
          case ${mergeMode} in
            update) update=true ;;
          esac
        fi
      fi

      if [ "${update}" ]; then
        bashcli-debug "${property}=${value}"
        BASHCLI_CONFIG_PROPERTIES[${property}]=${value}
        BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]=${profile}
      fi
    fi
    ((++lineNumber))
  done < "${configFile}"
}

-bashcli-config-read-line() {
  local line=$1
  local configFile=$2
  local lineNumber=$3
  local profile property value

  if [[ ${line} == *( )\#* ]]; then
    return 1
  fi

  property=${line%%=*}
  value=${line#*=}
  bashcli-string-trim property
  bashcli-string-trim value

  -bashcli-config-split-profile "${property}"
  profile=${REPLY[0]:-default}
  property=${REPLY[1]}

  if [ -z "${property}" ]; then
    bashcli-warn "failed to read line ${lineNumber} of file ${configFile}"
    return 1
  fi

  bashcli-config-check-property "${property}"

  bashcli-debug "${profile} ${property} ${value}"
  REPLY=("${profile}" "${property}" "${value}")
}

-bashcli-config-split-profile() {
  local property=$1
  local profile=
  if [[ ${property} == %* ]]; then
    profile=${property%%.*}
    property=${property:${#profile}}
    property=${property:1}
    profile=${profile#\%}
  fi
  REPLY=("${profile}" "${property}")
}

-bashcli-config-write-value() {
  local unset=${1/--set/}
  local profile=$2
  local property=$3
  local value=$4
  local profilePrefix
  local configFile
  local tempFile=$(mktemp)

  trap 'rm -f -- "${tempFile}"' RETURN

  configFile=$(bashcli-config-file)

  if [ "${profile}" != default ]; then
    profilePrefix="%${profile}."
  fi

  if [ -f "${configFile}" ]; then
    while IFS= read -r line || [ -n "${line}" ]; do
      if -bashcli-config-read-line "${line}" "${configFile}" "${lineNumber}"; then
        if [ "${profile}" == "${REPLY[0]}" ] && [ "${property}" == "${REPLY[1]}" ]; then
          if [ "${unset}" != true ]; then
            unset=true
            printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}"
          fi
        else
          printf "%s\n" "${line}"
        fi
      fi
      ((++lineNumber))
    done < "${configFile}" > "${tempFile}"
    if [ "${unset}" != true ]; then
      printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}" >> "${tempFile}"
    fi
    mv "${tempFile}" "${configFile}"
  else
    printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}" > "${configFile}"
  fi
}

-bashcli-config-read-env() {
  local index property profile propertyProfile profileIndex

  for property in "${!BASHCLI_CONFIG_PROPERTIES[@]}"; do
    propertyProfile=${BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]}
    profileIndex=${BASHCLI_CONFIG_PROFILE_INDEX[${propertyProfile}]}
    for ((index = $((${#BASHCLI_CONFIG_PROFILES[@]} - 1)); index >= ${profileIndex}; --index)); do
      profile=${BASHCLI_CONFIG_PROFILES[${index}]}
      if -bashcli-config-env-get "${profile}" "${property}"; then
        BASHCLI_CONFIG_PROPERTIES[${property}]=${REPLY}
        BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]=${profile}
        break
      fi
    done
  done
}

-bashcli-config-env-get() {
  local profile=$1
  local property=$2
  local envVariable=${BASHCLI_CLI_NAME}_

  if [ "${profile}" != default ]; then
    property="%${profile}.${property}"
  fi
  envVariable+=${property}
  envVariable=${envVariable//[^a-zA-Z0-9]/_}
  envVariable=${envVariable^^}

  if [ "${BASHCLI_CONFIG_ENV[${envVariable}]}" ]; then
    REPLY=${!envVariable}
    bashcli-debug "${property} -> ${envVariable} -> ${REPLY}"
    return 0
  fi

  return 1
}

bashcli-config-check-property() {
  local property=$1
  if [[ ${property} != ${BASHCLI_CONFIG_PROPERTY_PATTERN} ]]; then
    bashcli-error "invalid property name: ${property} (should match '${BASHCLI_CONFIG_PROPERTY_PATTERN}')"
    return 1
  fi
}

-bashcli-config-initialize-profiles() {
  local profile
  local profiles=(default "${BASHCLI_CONFIG_PROFILES[@]}")
  local index=0

  BASHCLI_CONFIG_PROFILES=()
  BASHCLI_CONFIG_PROFILE_INDEX=()

  # Check profile-names, remove duplicate and empty profiles, while keeping the order.
  for ((index = $((${#profiles[@]})); index >= 0; --index)); do
    profile=${profiles[index]}
    if [ "${profile}" ] && [ -z "${BASHCLI_CONFIG_PROFILE_INDEX[${profile}]}" ]; then
      if [[ ${profile} != ${BASHCLI_CONFIG_PROFILE_PATTERN} ]]; then
        bashcli-error "invalid profile name: ${profile} (should match '${BASHCLI_CONFIG_PROFILE_PATTERN}')"
        return 1
      fi
      BASHCLI_CONFIG_PROFILE_INDEX[${profile}]=${index}
      BASHCLI_CONFIG_PROFILES=("${profile}" "${BASHCLI_CONFIG_PROFILES[@]}")
      # shellcheck disable=2034
      BASHCLI_CONFIG_KNOWN_PROFILES[${profile}]=1
    fi
  done

  # Fix the index.
  BASHCLI_CONFIG_PROFILE_INDEX=()
  for ((index = 0; index < ${#BASHCLI_CONFIG_PROFILES[@]}; ++index)); do
    profile=${BASHCLI_CONFIG_PROFILES[index]}
    BASHCLI_CONFIG_PROFILE_INDEX[${profile}]=${index}
  done
}

-bashcli-config-initialize-scope() {
  case ${BASHCLI_CONFIG_SCOPE} in
    global|local|'') ;;
    *) bashcli-error "invalid scope: ${scope} (should be 'global', 'local' or empty)"
       return 1;;
  esac

  if [ "${BASHCLI_CONFIG_SCOPE}" == local ] && [ -z "${BASHCLI_CONFIG_LOCAL}" ]; then
    bashcli-error "local scope not supported"
    return 1
  fi
}

-bashcli-config-initialize-env() {
  local IFS line variableName

  BASHCLI_CONFIG_ENV=()
  while IFS= read -r line || [ -n "${line}" ]; do
    variableName=${line%%=*}
    BASHCLI_CONFIG_ENV[${variableName}]=1
  done < <(env)
}

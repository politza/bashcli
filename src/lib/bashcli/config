#!/usr/bin/env bash

declare -g BASHCLI_CONFIG_GLOBAL=${BASHCLI_CONFIG_GLOBAL:-${XDG_CONFIG_HOME:-$HOME/.config}/${BASHCLI_CLI_NAME}/${BASHCLI_CLI_NAME}.conf}
declare -g BASHCLI_CLI_CONFIG_LOCAL=${BASHCLI_CLI_CONFIG_LOCAL}
declare -g BASHCLI_CONFIG_DEFAULT=${BASHCLI_CONFIG_DEFAULT:-${BASHCLI_CLI_DIR}/conf/default.conf}

declare -g BASHCLI_CONFIG_PROPERTY_PATTERN='+([a-zA-Z0-9._-])'
declare -g BASHCLI_CONFIG_PROFILE_PATTERN='+([a-zA-Z0-9-])'

declare -g BASHCLI_CONFIG_MAX_EVAL_DEPTH=${BASHCLI_CONFIG_MAX_EVAL_DEPTH:-16}
declare -g BASHCLI_CONFIG_EVAL_DEPTH=0

declare -g BASHCLI_CONFIG_INITIALIZED=

declare -g -A BASHCLI_CONFIG_PROPERTIES=()
declare -g -A BASHCLI_CONFIG_PROPERTY_PROFILE=()

declare -g    BASHCLI_CONFIG_ACTIVE_PROFILES=()
declare -g -A BASHCLI_CONFIG_ACTIVE_PROFILES_ORDER=()
declare -g -A BASHCLI_CONFIG_PROFILES=()

declare -g -A BASHCLI_CONFIG_ENV=()

declare -g BASHCLI_CONFIG_SCOPE=

bashcli-config-get() {
  local property=$1
  local profile value isSet

  case $# in
    0) bashcli-error "property-name parameter missing"
       return 1 ;;
    1) ;;
    *) bashcli-error "too many arguments: $*"
       return 1;;
  esac

  -bashcli-config-check-property "${property}"
  bashcli-config-initialize

  profile=${BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]}

  if -bashcli-config-env-get "${profile:-default}" "${property}"; then
    value=${REPLY}
    isSet=1
  elif [ "${profile}" ]; then
    value=${BASHCLI_CONFIG_PROPERTIES[${property}]}
    isSet=1
  fi

  if [ "${isSet}" ]; then
    -bashcli-config-eval "${value}"
    bashcli-debug "${profile:-default} ${property} ${REPLY}"
    return 0
  else
    bashcli-debug "${profile:-default} ${property} <unset>"
  fi
  return 1
}

bashcli-config-get-list() {
  local property=$1
  local index list value IFS

  if bashcli-config-get "${property}"; then
    IFS=,
    readarray -d, -t list <<<"${REPLY}"
    REPLY=()
    for ((index = 0; index < ${#list[@]}; ++index)); do
      value=${list[index]}
      bashcli-string-trim value
      REPLY+=("${value}")
    done
    return 0
  fi
  return 1
}

bashcli-config-get-boolean() {
  local property=$1

  if bashcli-config-get "${property}"; then
    if [ "${REPLY}" != true ]; then
      REPLY=false
    fi
    return 0
  fi

  return 1
}

bashcli-config-set() {
  case $# in
    0) bashcli-error "property-name parameter missing"
       return 1 ;;
    1) bashcli-error "property-value parameter missing"
       return 1 ;;
    2) ;;
    *) bashcli-error "too many arguments: $*"
       return 1 ;;
  esac

  -bashcli-config-set --set "$@"
}

bashcli-config-unset() {
  case $# in
    0) bashcli-error "property-name parameter missing"
       return 1 ;;
    1) ;;
    *) bashcli-error "too many arguments: $*"
       return 1 ;;
  esac

  -bashcli-config-set --unset "$@"
}

bashcli-config-list() {
  local IFS=$'\n'
  local property
  local properties
  local value

  if [ $# -gt 0 ]; then
    bashcli-error "too many arguments: $*"
    return 1
  fi

  bashcli-config-initialize
  properties=($(LC_ALL=C sort <<<"${!BASHCLI_CONFIG_PROPERTIES[@]}"))

  for property in "${properties[@]}"; do
    if bashcli-config-get "${property}"; then
       value=${REPLY}
       -bashcli-config-escape value
       printf "%s=%s\n" "${property}" "${value}"
    fi
  done
}

bashcli-config-initialize() {
  local IFS line profile

  if [ "${BASHCLI_CONFIG_INITIALIZED}" ]; then
    return
  fi
  BASHCLI_CONFIG_INITIALIZED=1

  bashcli-debug "initializing"

  -bashcli-config-initialize-profiles
  -bashcli-config-initialize-scope
  -bashcli-config-initialize-env
  -bashcli-config-read

  bashcli-debug "read ${#BASHCLI_CONFIG_PROPERTIES[@]} properties"
}

bashcli-config-reinitialize() {
  BASHCLI_CONFIG_INITIALIZED=
  bashcli-config-initialize
}

bashcli-config-file() {
  local configFile
  local scope=${BASHCLI_CONFIG_SCOPE}

  if [ -z "${scope}" ]; then
    if [ "${BASHCLI_CLI_CONFIG_LOCAL}" ]; then
      scope=local
    else
      scope=global
    fi
  fi

  case ${scope} in
    global) configFile=${BASHCLI_CONFIG_GLOBAL} ;;
    local) configFile=${BASHCLI_CLI_CONFIG_LOCAL} ;;
    *) bashcli-fatal "internal error: invalid scope: ${scope}" ;;
  esac
  if [ -z "${configFile}" ]; then
    bashcli-error "property file unset"
    return 1
  fi

  if [ ! -f "${configFile}" ]; then
    mkdir --parents "$(dirname "${configFile}")"
  fi

  printf "%s" "${configFile}"
}

-bashcli-config-eval() {
  local initialValue=$1
  local value=${initialValue}
  local result=
  local prefix expr exprValue property default
  REPLY=

  if [[ "${value}" != *[\$\\]* ]]; then
    REPLY=${value}
    return
  fi

  if [ ${BASHCLI_CONFIG_EVAL_DEPTH} -gt "${BASHCLI_CONFIG_MAX_EVAL_DEPTH}" ]; then
    bashcli-fatal "apparent cyclic property dependencies found during evaluation"
  fi

  trap "((--BASHCLI_CONFIG_EVAL_DEPTH)) || true" RETURN
  ((++BASHCLI_CONFIG_EVAL_DEPTH))

  while [ "${value}" ]; do
    prefix=${value%%[\$\\]*}
    value=${value:${#prefix}}
    result+=${prefix}

    case ${value:0:1} in
      \\) case ${value:1:1} in
            n) result+=$'\n' ;;
            r) result+=$'\r' ;;
            t) result+=$'\t' ;;
            s) result+=' ' ;;
            *) result+=${value:1:1} ;;
          esac
          value=${value:2} ;;
      \$) if [ "${value:1:1}" != '{' ]; then
            result+='$'
            value=${value:1}
          else
            value=${value:2}
            expr=${value%%\}*}
            value=${value:${#expr}}
            value=${value:1}
            property=${expr%%\:*}
            default=${expr:$((${#property} + 1))}
            if ! -bashcli-config-check-property "${property}"; then
              bashcli-error "failed to evaluate '${initialValue}'"
              return 1
            fi
            if [ "${BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]}" ]; then
              exprValue=${BASHCLI_CONFIG_PROPERTIES[${property}]}
            elif [ "${BASHCLI_CONFIG_ENV[${property}]}" ]; then
              exprValue=${!property}
            fi
            if [ -z "${exprValue}" ]; then
              exprValue=${default}
            fi
            if [ "${exprValue}" ]; then
              -bashcli-config-eval "${exprValue}"
              result+=${REPLY}
            fi
          fi
          ;;
      esac
  done

  REPLY=${result}
}

-bashcli-config-escape() {
  local -n _value=$1
  local _spaces

  _value=${_value//$'\n'/\\n}
  _value=${_value//$'\r'/\\r}
  _value=${_value//$'\t'/\\t}
  _spaces=${_value%%[^ ]*}
  _value=${_spaces//?/\\s}${_value:${#_spaces}}
  _spaces=${_value##*[^ ]}
  _value=${_value:0:$((${#_value} - ${#_spaces}))}${_spaces//?/\\s}
}

-bashcli-config-set() {
  local updateMode=$1
  local property=$2
  local value=$3
  local profile=

  if [ ${#BASHCLI_CONFIG_ACTIVE_PROFILES[@]} -gt 0 ]; then
    profile=${BASHCLI_CONFIG_ACTIVE_PROFILES[-1]}
  fi

  bashcli-string-trim property
  bashcli-string-trim value

  -bashcli-config-check-property "${property}"
  bashcli-debug "${profile}" "${property}" "${value}"
  -bashcli-config-write-value "${updateMode}" "${profile}" "${property}" "${value}"
}

-bashcli-config-read() {
  local IFS=,
  local configFiles=()
  local configFile

  if [ -f "${BASHCLI_CONFIG_DEFAULT}" ]; then
    configFiles+=("${BASHCLI_CONFIG_DEFAULT}")
  fi

  if [ -z "${BASHCLI_CONFIG_SCOPE}" ] || [ "${BASHCLI_CONFIG_SCOPE}" == global ]; then
    configFiles+=("${BASHCLI_CONFIG_GLOBAL}")
  fi

  if [ -z "${BASHCLI_CONFIG_SCOPE}" ] || [ "${BASHCLI_CONFIG_SCOPE}" == local ]; then
    configFiles+=("${BASHCLI_CLI_CONFIG_LOCAL}")
  fi

  bashcli-debug "reading in scope ${BASHCLI_CONFIG_SCOPE:-<none>} with profiles [${BASHCLI_CONFIG_ACTIVE_PROFILES[*]}]"

  for configFile in "${configFiles[@]}"; do
    if [ -f "${configFile}" ]; then
      -bashcli-config-read-file "${configFile}"
    fi
  done
}

-bashcli-config-read-file() {
  local configFile=$1
  local lineNumber=1
  local index line property value
  local profile priority propertyProfile currentPriority update

  bashcli-debug "reading ${configFile}"

  while IFS= read -r line || [ -n "${line}" ]; do
    if -bashcli-config-read-line "${line}" "${configFile}" "${lineNumber}"; then
      profile=${REPLY[0]}
      property=${REPLY[1]}
      value=${REPLY[2]}
      propertyProfile=${BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]}
      BASHCLI_CONFIG_PROFILES[${profile}]=1
      update=

      if [ -z "${BASHCLI_CONFIG_ACTIVE_PROFILES_ORDER[${profile}]}" ]; then
        # Profile is not active.
        :
      elif [ -z "${propertyProfile}" ]; then
        # Property is not yet set.
        update=true
      else
        priority=${BASHCLI_CONFIG_ACTIVE_PROFILES_ORDER[${profile}]}
        currentPriority=${BASHCLI_CONFIG_ACTIVE_PROFILES_ORDER[${propertyProfile}]}

        if [ "${priority}" -gt "${currentPriority}" ]; then
          update=true
        elif [ "${priority}" -eq "${currentPriority}" ]; then
          update=true
        fi
      fi

      if [ "${update}" ]; then
        BASHCLI_CONFIG_PROPERTIES[${property}]=${value}
        BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]=${profile}
      fi
    fi
    ((++lineNumber))
  done < "${configFile}"
}

-bashcli-config-read-line() {
  local line=$1
  local configFile=$2
  local lineNumber=$3
  local profile=default
  local property value

  if [[ ${line} == *([[:space:]])?(\#*) ]]; then
    return 1
  fi

  property=${line%%=*}
  value=${line#*=}
  # inlined bashcli-string-trim for performance
  property=${property##+([ $'\t\r\n'])}
  property=${property%%+([ $'\t\r\n'])}
  value=${value##+([ $'\t\r\n'])}
  value=${value%%+([ $'\t\r\n'])}

  if [[ ${property} == %* ]]; then
    profile=${property%%.*}
    property=${property:${#profile}}
    property=${property:1}
    profile=${profile#\%}
  fi

  if [ -z "${property}" ]; then
    bashcli-warn "failed to read line ${lineNumber} of file ${configFile}"
    return 1
  fi

  # inlined -bashcli-config-check-property for performance
  if [[ ${property} != ${BASHCLI_CONFIG_PROPERTY_PATTERN} ]]; then
    bashcli-error "invalid property name: ${property} (should match '${BASHCLI_CONFIG_PROPERTY_PATTERN}')"
    return 1
  fi

  REPLY=("${profile}" "${property}" "${value}")
}

-bashcli-config-write-value() {
  local unset=${1/--set/}
  local profile=$2
  local property=$3
  local value=$4
  local profilePrefix
  local configFile
  local tempFile=$(mktemp)
  local updated=

  trap 'rm -f -- "${tempFile}"' RETURN

  configFile=$(bashcli-config-file)
  -bashcli-config-escape value

  if [ "${profile}" != default ]; then
    profilePrefix="%${profile}."
  fi

  if [ -f "${configFile}" ]; then
    while IFS= read -r line || [ -n "${line}" ]; do
      if -bashcli-config-read-line "${line}" "${configFile}" "${lineNumber}"; then
        if [ "${profile}" == "${REPLY[0]}" ] && [ "${property}" == "${REPLY[1]}" ]; then
          if [ -z "${unset}" ]; then
            updated=true
            printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}"
          fi
        else
          printf "%s\n" "${line}"
        fi
      else
        printf "%s\n" "${line}"
      fi
      ((++lineNumber))
    done < "${configFile}" > "${tempFile}"
    if [ -z "${unset}" ] && [ -z "${updated}" ]; then
      printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}" >> "${tempFile}"
    fi
    mv "${tempFile}" "${configFile}"
  elif [ -z "${unset}" ]; then
    printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}" > "${configFile}"
  fi
}

-bashcli-config-env-get() {
  local profile
  local minProfile=$1
  local property=$2
  local minIndex=${BASHCLI_CONFIG_ACTIVE_PROFILES_ORDER[${minProfile}]}

  if [ -z "${minIndex}" ]; then
    bashcli-error "internal error: profile not active: ${minProfile}"
    return 1
  fi

  for ((index = $((${#BASHCLI_CONFIG_ACTIVE_PROFILES[@]} - 1)); index >= ${minIndex}; --index)); do
    profile=${BASHCLI_CONFIG_ACTIVE_PROFILES[${index}]}
    if -bashcli-config-env-read "${profile}" "${property}"; then
      return 0
    fi
  done

  return 1
}

-bashcli-config-env-read() {
  local profile=$1
  local property=$2
  local envVariable=${BASHCLI_CLI_NAME}_

  if [ "${profile}" != default ]; then
    property="%${profile}.${property}"
  fi
  envVariable+=${property}
  envVariable=${envVariable//[^a-zA-Z0-9]/_}
  envVariable=${envVariable^^}

  if [ "${BASHCLI_CONFIG_ENV[${envVariable}]}" ]; then
    REPLY=${!envVariable}
    bashcli-debug "${property} -> ${envVariable} -> ${REPLY}"
    return 0
  fi

  return 1
}

-bashcli-config-check-property() {
  local property=$1
  if [[ ${property} != ${BASHCLI_CONFIG_PROPERTY_PATTERN} ]]; then
    bashcli-error "invalid property name: ${property} (should match '${BASHCLI_CONFIG_PROPERTY_PATTERN}')"
    return 1
  fi
}

-bashcli-config-initialize-profiles() {
  local profile
  local profiles=(default "${BASHCLI_CONFIG_ACTIVE_PROFILES[@]}")
  local index=0

  BASHCLI_CONFIG_ACTIVE_PROFILES=()
  BASHCLI_CONFIG_ACTIVE_PROFILES_ORDER=()

  # Check profile-names, remove duplicate and empty profiles, but keep the order.
  for ((index = $((${#profiles[@]})); index >= 0; --index)); do
    profile=${profiles[index]}
    if [ "${profile}" ] && [ -z "${BASHCLI_CONFIG_ACTIVE_PROFILES_ORDER[${profile}]}" ]; then
      if [[ ${profile} != ${BASHCLI_CONFIG_PROFILE_PATTERN} ]]; then
        bashcli-error "invalid profile name: ${profile} (should match '${BASHCLI_CONFIG_PROFILE_PATTERN}')"
        return 1
      fi
      BASHCLI_CONFIG_ACTIVE_PROFILES_ORDER[${profile}]=${index}
      BASHCLI_CONFIG_ACTIVE_PROFILES=("${profile}" "${BASHCLI_CONFIG_ACTIVE_PROFILES[@]}")
      # shellcheck disable=2034
      BASHCLI_CONFIG_PROFILES[${profile}]=1
    fi
  done

  # Fix the index.
  BASHCLI_CONFIG_ACTIVE_PROFILES_ORDER=()
  for ((index = 0; index < ${#BASHCLI_CONFIG_ACTIVE_PROFILES[@]}; ++index)); do
    profile=${BASHCLI_CONFIG_ACTIVE_PROFILES[index]}
    BASHCLI_CONFIG_ACTIVE_PROFILES_ORDER[${profile}]=${index}
  done
}

-bashcli-config-initialize-scope() {
  case ${BASHCLI_CONFIG_SCOPE} in
    global|local|'') ;;
    *) bashcli-error "invalid scope: ${scope} (should be 'global', 'local' or empty)"
       return 1;;
  esac

  if [ "${BASHCLI_CONFIG_SCOPE}" == local ] && [ -z "${BASHCLI_CLI_CONFIG_LOCAL}" ]; then
    bashcli-error "local scope not supported"
    return 1
  fi
}

-bashcli-config-initialize-env() {
  local IFS line name

  BASHCLI_CONFIG_ENV=()
  while IFS= read -r line || [ -n "${line}" ]; do
    name=${line%%=*}
    if [[ ${name} != BASHCLI_* ]]; then
      BASHCLI_CONFIG_ENV[${name}]=1
    fi
  done < <(env)
}

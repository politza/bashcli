#!/usr/bin/env bash

declare -g BASHCLI_CONFIG_GLOBAL=${BASHCLI_CONFIG_GLOBAL:-${XDG_CONFIG_HOME:-$HOME/.config}/${BASHCLI_CLI_NAME}/${BASHCLI_CLI_NAME}.conf}
declare -g BASHCLI_CONFIG_LOCAL=${BASHCLI_CONFIG_LOCAL}

declare -g BASHCLI_CONFIG_VALID_PROPERTY_NAME='+([a-zA-Z0-9.-])'
declare -g BASHCLI_CONFIG_VALID_PROFILE_NAME='+([a-zA-Z0-9-])'

declare -g BASHCLI_CONFIG_INITIALIZED=false

declare -g -A BASHCLI_CONFIG_PROPERTIES=()
declare -g -A BASHCLI_CONFIG_PROPERTY_PROFILE=()

declare -g BASHCLI_CONFIG_PROFILES=()
declare -g -A BASHCLI_CONFIG_PROFILE_INDEX=()
declare -g -A BASHCLI_CONFIG_KNOWN_PROFILES=()

declare -g -A BASHCLI_CONFIG_ENV=()

declare -g BASHCLI_CONFIG_SCOPE=

bashcli-config-get() {
  local property=$1

  case $# in
    0) bashcli-error "property-name parameter missing"
       return 1 ;;
    1) ;;
    *) bashcli-error "too many arguments: $*"
       return 1;;
  esac

  bashcli-config-initialize
  bashcli-config-check-property "${property}"

  if [ "${BASHCLI_CONFIG_PROPERTIES[${property}]}" ]; then
    printf "%s\n" "${BASHCLI_CONFIG_PROPERTIES[${property}]}"
  fi
}

bashcli-config-set() {
  case $# in
    0) bashcli-error "property-name parameter missing"
       return 1 ;;
    1) bashcli-error "property-value parameter missing"
       return 1 ;;
    2) ;;
    *) bashcli-error "too many arguments: $*"
       return 1 ;;
  esac

  -bashcli-config-set false "$@"
}

bashcli-config-unset() {
  case $# in
    0) bashcli-error "property-name parameter missing"
       return 1 ;;
    1) ;;
    *) bashcli-error "too many arguments: $*"
       return 1 ;;
  esac

  -bashcli-config-set true "$@"
}

bashcli-config-list() {
  local IFS=$'\n'
  local property
  local properties

  if [ $# -gt 0 ]; then
    bashcli-error "too many arguments: $*"
    return 1
  fi

  bashcli-config-initialize
  properties=($(LC_ALL=C sort <<<"${!BASHCLI_CONFIG_PROPERTIES[@]}"))

  for property in "${properties[@]}"; do
    printf "%s=%s\n" "${property}" "${BASHCLI_CONFIG_PROPERTIES[${property}]}"
  done
}

bashcli-config-initialize() {
  local IFS line variableName profile

  if [ "${BASHCLI_CONFIG_INITIALIZED}" == true ]; then
    return
  fi
  BASHCLI_CONFIG_INITIALIZED=true

  -bashcli-config-initialize-profiles
  -bashcli-config-initialize-scope
  -bashcli-config-initialize-env
  -bashcli-config-read
  -bashcli-config-read-env

  IFS=,
  bashcli-debug "known profiles: [${!BASHCLI_CONFIG_KNOWN_PROFILES[*]}]"
}

bashcli-config-reinitialize() {
  BASHCLI_CONFIG_INITIALIZED=false
  bashcli-config-initialize
}

bashcli-config-file() {
  local configFile
  local scope=${BASHCLI_CONFIG_SCOPE}

  if [ -z "${scope}" ]; then
    if [ "${BASHCLI_CONFIG_LOCAL}" ]; then
      scope=local
    else
      scope=global
    fi
  fi

  case ${scope} in
    global) configFile=${BASHCLI_CONFIG_GLOBAL} ;;
    local) configFile=${BASHCLI_CONFIG_LOCAL} ;;
    *) bashcli-fatal "internal error: invalid scope: ${scope}" ;;
  esac
  if [ -z "${configFile}" ]; then
    bashcli-error "property file unset"
    return 1
  fi
  printf "%s" "${configFile}"
}

-bashcli-config-set() {
  local unset=$1
  local property=$2
  local value=$3
  local profile=

  if [ ${#BASHCLI_CONFIG_PROFILES[@]} -gt 0 ]; then
    profile=${BASHCLI_CONFIG_PROFILES[-1]}
  fi

  bashcli-string-trim property
  bashcli-string-trim value

  bashcli-config-check-property "${property}"
  bashcli-debug "${profile:-"''"}" "${property}" "${value}"
  -bashcli-config-write-value "${unset}" "${profile}" "${property}" "${value}"
}

-bashcli-config-read() {
  local IFS=,
  local configFiles=()
  local configFile

  if [ -z "${BASHCLI_CONFIG_SCOPE}" ] || [ "${BASHCLI_CONFIG_SCOPE}" == global ]; then
    configFiles+=("${BASHCLI_CONFIG_GLOBAL}")
  fi

  if [ -z "${BASHCLI_CONFIG_SCOPE}" ] || [ "${BASHCLI_CONFIG_SCOPE}" == local ]; then
    configFiles+=("${BASHCLI_CONFIG_LOCAL}")
  fi

  bashcli-debug "reading in scope ${BASHCLI_CONFIG_SCOPE:-"''"} with profiles [${BASHCLI_CONFIG_PROFILES[*]}]"

  for configFile in "${configFiles[@]}"; do
    if [ -f "${configFile}" ]; then
      -bashcli-config-read-file "${configFile}"
    fi
  done
}

-bashcli-config-read-file() {
  local configFile
  local -n profileIndex=BASHCLI_CONFIG_PROFILE_INDEX
  local lineNumber=0
  local index line property value
  local profile priority currentProfile currentPriority
  local mergeMode=update
  local option

  while getopts "m:" option; do
    case ${option} in
      m) case ${OPTARG} in
           keep|update) ;;
           *) bashcli-error "internal error: invalid merge mode: ${OPTARG}"
              return 1;;
         esac
         mergeMode=${OPTARG} ;;
      ?) return 1;;
    esac
  done

  if [ $# -ne 1 ]; then
    bashcli-error "internal error: single configFile argument expected"
    return 1
  fi
  shift "$((OPTIND - 1))"
  configFile=$1

  bashcli-debug "reading ${configFile}"

  while IFS= read -r line || [ -n "${line}" ]; do
    if -bashcli-config-read-line "${line}" "${configFile}" "${lineNumber}"; then
      profile=${REPLY[0]}
      property=${REPLY[1]}
      value=${REPLY[2]}
      priority=-1
      currentProfile=${BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]}
      currentPriority=-1

      if [ "${profile}" ]; then
        BASHCLI_CONFIG_KNOWN_PROFILES[${profile}]=1
        if [ "${profileIndex[${profile}]}" ]; then
          priority="${profileIndex[${profile}]}"
        fi
      fi

      if [ "${currentProfile}" ] && [ "${profileIndex[${currentProfile}]}" ]; then
        currentPriority=${profileIndex[${currentProfile}]}
      fi

      if [ "${mergeMode}" == keep ] && [ "${priority}" -le "${currentPriority}" ]; then
        continue
      elif [ "${priority}" -ge "${currentPriority}" ]; then
        BASHCLI_CONFIG_PROPERTIES[${property}]=${value}
        BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]=${profile}
      fi
    fi
    ((++lineNumber))
  done < "${configFile}"
}

-bashcli-config-read-line() {
  local line=$1
  local configFile=$2
  local lineNumber=$3
  local profile property value

  if [[ ${line} == *( )\#* ]]; then
    return 1
  fi

  property=${line%%=*}
  value=${line#*=}
  bashcli-string-trim property
  bashcli-string-trim value

  -bashcli-config-split-profile "${property}"
  profile=${REPLY[0]}
  property=${REPLY[1]}

  if [ -z "${property}" ]; then
    bashcli-warn "failed to read line ${lineNumber} of file ${configFile}"
    return 1
  fi

  bashcli-config-check-property "${property}"

  bashcli-debug "${profile:-"''"} ${property} ${value}"
  REPLY=("${profile}" "${property}" "${value}")
}

-bashcli-config-split-profile() {
  local property=$1
  local profile=
  if [[ ${property} == %* ]]; then
    profile=${property%%.*}
    property=${property:${#profile}}
    property=${property:1}
    profile=${profile#\%}
  fi
  REPLY=("${profile}" "${property}")
}

-bashcli-config-write-value() {
  local unset=$1
  local profile=$2
  local property=$3
  local value=$4
  local profilePrefix
  local configFile
  local tempFile=$(mktemp)

  trap 'rm -f -- "${tempFile}"' RETURN

  configFile=$(bashcli-config-file)

  if [ "${profile}" ]; then
    profilePrefix="%${profile}."
  fi

  if [ -f "${configFile}" ]; then
    while IFS= read -r line || [ -n "${line}" ]; do
      if -bashcli-config-read-line "${line}" "${configFile}" "${lineNumber}"; then
        if [ "${profile}" == "${REPLY[0]}" ] && [ "${property}" == "${REPLY[1]}" ]; then
          if [ "${unset}" != true ]; then
            unset=true
            printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}"
          fi
        else
          printf "%s\n" "${line}"
        fi
      fi
      ((++lineNumber))
    done < "${configFile}" > "${tempFile}"
    if [ "${unset}" != true ]; then
      printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}" >> "${tempFile}"
    fi
    mv "${tempFile}" "${configFile}"
  else
    printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}" > "${configFile}"
  fi
}

-bashcli-config-read-env() {
  local index property profile profileIndex
  local profileCount=${#BASHCLI_CONFIG_PROFILES[@]}

  for property in "${!BASHCLI_CONFIG_PROPERTIES[@]}"; do
    profileIndex=${BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]:-${profileCount}}
    for ((index = 0; index <= ${profileIndex}; ++index)); do
      if [ ${index} -lt "${profileCount}" ]; then
        profile=${BASHCLI_CONFIG_PROFILES[${index}]}
      else
        profile=
      fi
      if -bashcli-config-env-get "${profile}" "${property}"; then
        BASHCLI_CONFIG_PROPERTIES[${property}]=${REPLY}
        BASHCLI_CONFIG_PROPERTY_PROFILE[${property}]=${profile}
        break
      fi
    done
  done
}

-bashcli-config-env-get() {
  local profile=$1
  local property=$2
  local envVariable=${BASHCLI_CLI_NAME}_

  if [ "${profile}" ]; then
    envVariable+="_${profile}_"
  fi
  envVariable+=${property}
  envVariable=${envVariable//[^a-zA-Z0-9]}
  envVariable=${envVariable^^}

  bashcli-debug "checking ${envVariable}"
  if [ "${BASHCLI_CONFIG_ENV[${envVariable}]}" ]; then
    REPLY=${!envVariable}
    bashcli-debug "$1 -> ${REPLY}"
    return 0
  fi

  return 1
}

bashcli-config-check-property() {
  local property=$1
  if [[ ${property} != ${BASHCLI_CONFIG_VALID_PROPERTY_NAME} ]]; then
    bashcli-error "invalid property name: ${property} (should match '${BASHCLI_CONFIG_VALID_PROPERTY_NAME}')"
    return 1
  fi
}

-bashcli-config-initialize-profiles() {
  local profile
  local profiles=("${BASHCLI_CONFIG_PROFILES[@]}")
  local index=0

  BASHCLI_CONFIG_PROFILES=()
  BASHCLI_CONFIG_PROFILE_INDEX=()

  # Check profile-names, remove duplicate and empty profiles, while keeping the order.
  for ((index = $((${#profiles[@]})); index >= 0; --index)); do
    profile=${profiles[index]}
    if [ "${profile}" ] && [ -z "${BASHCLI_CONFIG_PROFILE_INDEX[${profile}]}" ]; then
      if [[ ${profile} != ${BASHCLI_CONFIG_VALID_PROFILE_NAME} ]]; then
        bashcli-error "invalid profile name: ${profile} (should match '${BASHCLI_CONFIG_VALID_PROFILE_NAME}')"
        return 1
      fi
      BASHCLI_CONFIG_PROFILE_INDEX[${profile}]=${index}
      BASHCLI_CONFIG_PROFILES=("${profile}" "${BASHCLI_CONFIG_PROFILES[@]}")
      # shellcheck disable=2034
      BASHCLI_CONFIG_KNOWN_PROFILES[${profile}]=1
    fi
  done

  # Fix the index.
  BASHCLI_CONFIG_PROFILE_INDEX=()
  for ((index = 0; index < ${#BASHCLI_CONFIG_PROFILES[@]}; ++index)); do
    profile=${BASHCLI_CONFIG_PROFILES[index]}
    BASHCLI_CONFIG_PROFILE_INDEX[${profile}]=${index}
  done
}

-bashcli-config-initialize-scope() {
  case ${BASHCLI_CONFIG_SCOPE} in
    global|local|'') ;;
    *) bashcli-error "invalid scope: ${scope} (should be 'global', 'local' or empty)"
       return 1;;
  esac

  if [ "${BASHCLI_CONFIG_SCOPE}" == local ] && [ -z "${BASHCLI_CONFIG_LOCAL}" ]; then
    bashcli-error "local scope not supported"
    return 1
  fi
}

-bashcli-config-initialize-env() {
  local IFS line variableName

  BASHCLI_CONFIG_ENV=()
  while IFS= read -r line || [ -n "${line}" ]; do
    variableName=${line%%=*}
    BASHCLI_CONFIG_ENV[${variableName}]=1
  done < <(env)
}

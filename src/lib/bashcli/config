#!/usr/bin/env bash

declare -g BASHCLI_CONFIG_GLOBAL_DIR=${BASHCLI_CONFIG_GLOBAL_DIR:-${XDG_CONFIG_HOME:-$HOME/.config}/${BASHCLI_CLI_NAME}}
declare -g BASHCLI_CONFIG_LOCAL_DIR=${BASHCLI_CONFIG_LOCAL_DIR}
declare -g BASHCLI_CONFIG_DEFAULT_DIR=${BASHCLI_CONFIG_DEFAULT_DIR:-${BASHCLI_CLI_DIR}/conf}

declare -g _BASHCLI_CONFIG_PROPERTY_PATTERN='+([a-zA-Z0-9._-])'
declare -g _BASHCLI_CONFIG_PROFILE_PATTERN='+([a-zA-Z0-9-])'

declare -g _BASHCLI_CONFIG_MAX_EVAL_DEPTH=${_BASHCLI_CONFIG_MAX_EVAL_DEPTH:-16}
declare -g _BASHCLI_CONFIG_EVAL_DEPTH=0

declare -g -A _BASHCLI_CONFIG_PROPERTIES=()
declare -g -A _BASHCLI_CONFIG_PROPERTIES_PROFILE=()

declare -g    _BASHCLI_CONFIG_PROFILES=()
declare -g -A _BASHCLI_CONFIG_PROFILE_PRIORITIES=()

declare -g -A _BASHCLI_CONFIG_ENV=()

bashcli-config-initialize() {
  local IFS=,
  bashcli-debug "initializing with profiles [$*]"
  unset IFS
  _BASHCLI_CONFIG_PROPERTIES=()
  _BASHCLI_CONFIG_PROPERTIES_PROFILE=()
  -bashcli-config-initialize-profiles "$@"
  -bashcli-config-initialize-env
}

bashcli-config-clear() {
  if [ $# -ne 0 ]; then
    bashcli-error "no arguments expected"
    return 1
  fi
  bashcli-config-initialize "${_BASHCLI_CONFIG_PROFILES[@]}"
}

bashcli-config-read() {
  local configFiles=()
  local namespace=${BASHCLI_CLI_NAME}
  local OPTIND=1
  local option scope prefixes configFile

  while getopts ":s:n:f:p:" option "$@"; do
    case ${option} in
      s) -bashcli-config-check-scope "${OPTARG}"
         scope=${OPTARG};;
      n) -bashcli-config-check-namespace "${OPTARG}"
         namespace=${OPTARG};;
      f) if [ "${OPTARG}" ]; then
           configFiles=("${OPTARG}")
         fi;;
      p) if [ "${OPTARG}" ]; then
           -bashcli-config-check-property "${OPTARG}"
           prefixes+=("${OPTARG}")
         fi;;
      :) bashcli-error "option requires an argument: ${OPTARG}"
         return 1;;
      *) bashcli-error "option not recognized: ${OPTARG}"
         return 1;;
    esac
  done

  if [ ${OPTIND} -le $# ]; then
    bashcli-error "too many arguments: $*"
    return 1
  fi

  if [ ${#configFiles[@]} -eq 0 ]; then
    bashcli-config-files "${scope}" "${namespace}"
    configFiles=("${REPLY[@]}")
  fi

  bashcli-debug "reading with namespace=${namespace} scope=${scope} #files=${#configFiles[@]}"

  for configFile in "${configFiles[@]}"; do
    if [ -f "${configFile}" ]; then
      -bashcli-config-read-file "${configFile}" "${namespace}" "${prefixes[@]}"
    else
      bashcli-debug "skipping non-regular or missing file: ${configFile}"
    fi
  done
}

bashcli-config-files() {
  local scope=$1
  local namespace=${2:-${BASHCLI_CLI_NAME}}

  REPLY=()
  case ${scope} in
    default) REPLY=("${BASHCLI_CONFIG_DEFAULT_DIR}/${namespace}.conf");;
    global) REPLY=("${BASHCLI_CONFIG_GLOBAL_DIR}/${namespace}.conf");;
    local) if [ "${BASHCLI_CONFIG_LOCAL_DIR}" ]; then
             REPLY=("${BASHCLI_CONFIG_LOCAL_DIR}/${namespace}.conf")
           else
             REPLY=("${BASHCLI_CONFIG_GLOBAL_DIR}/${namespace}.conf")
           fi;;
    '') REPLY=(
          "${BASHCLI_CONFIG_DEFAULT_DIR}/${namespace}.conf"
          "${BASHCLI_CONFIG_GLOBAL_DIR}/${namespace}.conf"
        )
        if [ "${BASHCLI_CONFIG_LOCAL_DIR}" ]; then
          REPLY+=("${BASHCLI_CONFIG_LOCAL_DIR}/${namespace}.conf")
        fi;;
    *) bashcli-error "no such scope: ${scope}"
       return 1
  esac
}

-bashcli-config-read-file() {
  local configFile=$1
  local namespace=$2
  shift 2
  local prefixes=("$@")
  local lineNumber=1
  local pattern=.
  local index line property qualifiedProperty
  local value profile priority propertyProfile currentPriority

  bashcli-debug "reading ${configFile}"

  if [ ${#prefixes[@]} -gt 0 ]; then
    bashcli-array-join prefixes '|'
    printf -v pattern "^[[:space:]]*(%%[a-zA-Z0-9-]+\\.)?(%s)\\." "${REPLY}"
  fi

  bashcli-debug "pattern=${pattern}"

  while IFS= read -r line || [ -n "${line}" ]; do
    if -bashcli-config-read-line "${line}" "${configFile}" "${lineNumber}"; then
      profile=${REPLY[0]}
      property=${namespace}.${REPLY[1]}
      value=${REPLY[2]}
      propertyProfile=${_BASHCLI_CONFIG_PROPERTIES_PROFILE[${property}]}

      if [ -z "${_BASHCLI_CONFIG_PROFILE_PRIORITIES[${profile}]}" ]; then
        # Profile is not active.
        continue
      elif [ "${propertyProfile}" ]; then
        # Property already set, check profile priorities.
        priority=${_BASHCLI_CONFIG_PROFILE_PRIORITIES[${profile}]}
        currentPriority=${_BASHCLI_CONFIG_PROFILE_PRIORITIES[${propertyProfile}]}

        if [ "${priority}" -lt "${currentPriority}" ]; then
          continue
        fi
      fi

      bashcli-debug "%${profile}.${property}=${value}"

      _BASHCLI_CONFIG_PROPERTIES[${property}]=${value}
      _BASHCLI_CONFIG_PROPERTIES_PROFILE[${property}]=${profile}
    fi
    ((++lineNumber))
  done < <(grep -E "${pattern}" "${configFile}")
}

bashcli-config-get() {
  local property qualifiedProperty profile value type
  local failIfUnset isSet
  local OPTIND=1
  local namespace=${BASHCLI_CLI_NAME}

  while getopts ":t:n:x" option "$@"; do
    case ${option} in
      t) type=${OPTARG};;
      n) -bashcli-config-check-namespace "${OPTARG}"
         namespace=${OPTARG};;
      x) failIfUnset=true;;
      :) bashcli-error "option requires an argument: ${OPTARG}"
         return 1;;
      *) bashcli-error "option not recognized: ${OPTARG}"
         return 1;;
    esac
  done
  shift "$((OPTIND - 1))"

  if [ $# -ne 1 ]; then
    bashcli-error "too many arguments"
    return 1
  fi

  property=$1
  qualifiedProperty=${namespace}.${property}
  -bashcli-config-check-property "${property}"
  profile=${_BASHCLI_CONFIG_PROPERTIES_PROFILE[${qualifiedProperty}]}

  if -bashcli-config-env-get "${profile:-default}" "${property}"; then
    value=${REPLY}
    isSet=true
  elif [ "${profile}" ]; then
    value=${_BASHCLI_CONFIG_PROPERTIES[${qualifiedProperty}]}
    isSet=true
  fi

  if [ "${isSet}" ]; then
    -bashcli-config-eval "${namespace}" "${value}"
    if [ "${type}" ]; then
      -bashcli-config-coerce-value "${REPLY}" "${type}"
    fi
    bashcli-debug "${profile:-default} ${property} ${REPLY}"
  else
    bashcli-debug "${profile:-default} ${property} <unset>"
  fi

  [ "${isSet}" ] || [ -z "${failIfUnset}" ]
}

-bashcli-config-coerce-value() {
  local value=$1
  local type=$2
  local array

  case ${type} in
    array)
      REPLY=()
      bashcli-string-split "${value}" , array
      for value in "${array[@]}"; do
        bashcli-string-trim value
        REPLY+=("${value}")
      done;;
    boolean)
      case ${value} in
        true) REPLY=true;;
        *) REPLY=false;;
      esac;;
    *)
      bashcli-error "type not supported: ${type}"
      return 1;;
  esac
}

bashcli-config-write() {
  local updateMode=set
  local namespace=${BASHCLI_CLI_NAME}
  local scope=local
  local profile=default
  local option configFile property value

  while getopts ":s:n:f:P:U" option "$@"; do
    case ${option} in
      s) -bashcli-config-check-scope "${OPTARG}"
         scope=${OPTARG};;
      n) -bashcli-config-check-namespace "${OPTARG}"
         namespace=${OPTARG};;
      f) if [ "${OPTARG}" ]; then
           configFiles=("${OPTARG}")
         fi;;
      U) updateMode=unset;;
      P) -bashcli-config-check-profile "${OPTARG}"
         profile="${OPTARG}";;
      :) bashcli-error "option requires an argument: ${OPTARG}"
         return 1;;
      *) bashcli-error "option not recognized: ${OPTARG}"
         return 1;;
    esac
  done

  shift "$((OPTIND - 1))"

  case ${updateMode}/$# in
    set/2);;
    unset/1);;
    set/*) bashcli-error "property and value arguments expected: $*"
           return 1;;
    unset/*) bashcli-error "property argument expected: $*"
             return 1;;
    *) bashcli-fatal "internal error";;
  esac

  property=$1
  value=$2
  bashcli-string-trim property
  bashcli-string-trim value
  -bashcli-config-check-property "${property}"

  if [ ${#configFiles[@]} -eq 0 ]; then
    bashcli-config-files "${scope}" "${namespace}"
    configFiles=("${REPLY[@]}")
    if [ ${#configFiles[@]} -ne 1 ]; then
      bashcli-fatal "internal error"
    fi
  fi
  configFile=${configFiles[0]}

  bashcli-debug "${updateMode}" "${configFile}" "${profile}" "${property}" "${value}"
  -bashcli-config-write-value "${updateMode}" "${configFile}" "${profile}" "${property}" "${value}"
}

-bashcli-config-write-value() {
  local updateMode=$1
  local configFile=$2
  local profile=$3
  local property=$4
  local value=$5
  local profilePrefix
  local configFile
  local tempFile=$(mktemp)
  local updated=

  trap 'rm -f -- "${tempFile}"' RETURN

  -bashcli-config-escape value

  if [ "${profile}" != default ]; then
    profilePrefix="%${profile}."
  fi

  if [ -f "${configFile}" ]; then
    while IFS= read -r line || [ -n "${line}" ]; do
      if ! -bashcli-config-read-line "${line}" "${configFile}" "${lineNumber}"; then
        printf "%s\n" "${line}"
        continue
      fi

      if [ "${profile}" == "${REPLY[0]}" ] && [ "${property}" == "${REPLY[1]}" ]; then
        # Update the value or remove it from the output, dependening on the update-mode.
        if [ "${updateMode}" == set ]; then
          updated=true
          printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}"
        fi
      else
        printf "%s\n" "${line}"
      fi
      ((++lineNumber))
    done < "${configFile}" > "${tempFile}"

    if [ "${updateMode}" == set ] && [ -z "${updated}" ]; then
      # Property was not found, append it.
      printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}" >> "${tempFile}"
    fi

    mv "${tempFile}" "${configFile}"
  elif [ -e "${configFile}" ]; then
    bashcli-error "not a regular file: ${configFile}"
    return 1
  elif [ "${updateMode}" == set ]; then
    # File does not exist yet, create it.
    printf "%s%s=%s\n" "${profilePrefix}" "${property}" "${value}" > "${configFile}"
  fi
}

# List all properties.
bashcli-config-list() {
  local property namespace qualifiedProperty qualifiedProperties

  if [ $# -ne 0 ]; then
    bashcli-error "no arguments expected"
    return 1
  fi

  qualifiedProperties=("${!_BASHCLI_CONFIG_PROPERTIES[@]}")
  bashcli-array-sort qualifiedProperties

  for qualifiedProperty in "${qualifiedProperties[@]}"; do
    namespace=${qualifiedProperties%%.*}
    property=${qualifiedProperty#*.}
    if bashcli-config-get -n "${namespace}" -x "${property}"; then
      -bashcli-config-escape REPLY
      printf "%s=%s\n" "${property}" "${REPLY}"
    fi
  done
}

-bashcli-config-eval() {
  local namespace=$1
  local initialValue=$2
  local value=${initialValue}
  local result prefix expr exprValue property qualifiedProperty default
  REPLY=

  if [[ "${value}" != *[\$\\]* ]]; then
    REPLY=${value}
    return 0
  fi

  if [ ${_BASHCLI_CONFIG_EVAL_DEPTH} -gt "${_BASHCLI_CONFIG_MAX_EVAL_DEPTH}" ]; then
    bashcli-fatal "apparent cyclic property dependencies found during evaluation"
  fi

  trap "((--_BASHCLI_CONFIG_EVAL_DEPTH)) || true" RETURN
  ((++_BASHCLI_CONFIG_EVAL_DEPTH))

  while [ "${value}" ]; do
    prefix=${value%%[\$\\]*}
    value=${value:${#prefix}}
    result+=${prefix}

    case ${value:0:1} in
      \\) case ${value:1:1} in
            n) result+=$'\n';;
            r) result+=$'\r';;
            t) result+=$'\t';;
            s) result+=' ';;
            *) result+=${value:1:1};;
          esac
          value=${value:2};;
      \$) if [ "${value:1:1}" != '{' ]; then
            result+='$'
            value=${value:1}
          else
            value=${value:2}
            expr=${value%%\}*}
            value=${value:${#expr}}
            value=${value:1}
            property=${expr%%\:*}
            default=${expr:$((${#property} + 1))}
            qualifiedProperty=${namespace}.${property}
            if [ "${_BASHCLI_CONFIG_PROPERTIES_PROFILE[${qualifiedProperty}]}" ]; then
              exprValue=${_BASHCLI_CONFIG_PROPERTIES[${qualifiedProperty}]}
            elif [ "${_BASHCLI_CONFIG_ENV[${property}]}" ]; then
              exprValue=${!property}
            fi
            if [ -z "${exprValue}" ]; then
              exprValue=${default}
            fi
            if [ "${exprValue}" ]; then
              -bashcli-config-eval "${namespace}" "${exprValue}"
              result+=${REPLY}
            fi
          fi;;
      esac
  done

  REPLY=${result}
}

-bashcli-config-escape() {
  local -n _value=$1
  local _spaces

  _value=${_value//$'\n'/\\n}
  _value=${_value//$'\r'/\\r}
  _value=${_value//$'\t'/\\t}
  _spaces=${_value%%[^ ]*}
  _value=${_spaces//?/\\s}${_value:${#_spaces}}
  _spaces=${_value##*[^ ]}
  _value=${_value:0:$((${#_value} - ${#_spaces}))}${_spaces//?/\\s}
}

-bashcli-config-read-line() {
  local line=$1
  local configFile=$2
  local lineNumber=$3
  local profile=default
  local property value

  bashcli-debug "reading: ${line}"
  if [[ ${line} == *([[:space:]])?(\#*) ]]; then
    return 1
  fi

  property=${line%%=*}
  value=${line#*=}
  # inlined bashcli-string-trim for performance
  property=${property##+([ $'\t\r\n'])}
  property=${property%%+([ $'\t\r\n'])}
  value=${value##+([ $'\t\r\n'])}
  value=${value%%+([ $'\t\r\n'])}

  if [[ ${property} == %* ]]; then
    profile=${property%%.*}
    property=${property:${#profile}}
    property=${property:1}
    profile=${profile#\%}
  fi

  if [ -z "${property}" ]; then
    bashcli-warn "failed to read line ${lineNumber} of file ${configFile}"
    return 1
  fi

  # inlined -bashcli-config-check-property for performance
  if [[ ${property} != ${_BASHCLI_CONFIG_PROPERTY_PATTERN} ]]; then
    bashcli-error "invalid property name: ${property} (should match '${_BASHCLI_CONFIG_PROPERTY_PATTERN}')"
    return 1
  fi

  REPLY=("${profile}" "${property}" "${value}")
}

-bashcli-config-env-get() {
  local profile
  local minProfile=$1
  local property=$2
  local minPriority=${_BASHCLI_CONFIG_PROFILE_PRIORITIES[${minProfile}]}

  if [ -z "${minPriority}" ]; then
    bashcli-error "internal error: profile not active: ${minProfile}"
    return 1
  fi

  for ((index = $((${#_BASHCLI_CONFIG_PROFILES[@]} - 1)); index >= ${minPriority}; --index)); do
    profile=${_BASHCLI_CONFIG_PROFILES[${index}]}
    if -bashcli-config-env-read "${profile}" "${property}"; then
      return 0
    fi
  done

  return 1
}

-bashcli-config-env-read() {
  local profile=$1
  local property=$2
  local envVariable=${BASHCLI_CLI_NAME}_

  if [ "${profile}" != default ]; then
    property="%${profile}.${property}"
  fi
  envVariable+=${property}
  envVariable=${envVariable//[^a-zA-Z0-9]/_}
  envVariable=${envVariable^^}

  if [ "${_BASHCLI_CONFIG_ENV[${envVariable}]}" ]; then
    REPLY=${!envVariable}
    bashcli-debug "${property} -> ${envVariable} -> ${REPLY}"
    return 0
  fi

  return 1
}

-bashcli-config-initialize-profiles() {
  local profile
  local profiles=(default "$@")
  local index=0

  _BASHCLI_CONFIG_PROFILES=()
  _BASHCLI_CONFIG_PROFILE_PRIORITIES=()

  # Check profile-names, remove duplicate and empty profiles, but keep the order.
  for ((index = $((${#profiles[@]})); index >= 0; --index)); do
    profile=${profiles[index]}
    if [ "${profile}" ] && [ -z "${_BASHCLI_CONFIG_PROFILE_PRIORITIES[${profile}]}" ]; then
      -bashcli-config-check-profile "${profile}"
      _BASHCLI_CONFIG_PROFILE_PRIORITIES[${profile}]=${index}
      _BASHCLI_CONFIG_PROFILES=("${profile}" "${_BASHCLI_CONFIG_PROFILES[@]}")
    fi
  done

  # Remove gaps from profile priorities.
  _BASHCLI_CONFIG_PROFILE_PRIORITIES=()
  for ((index = 0; index < ${#_BASHCLI_CONFIG_PROFILES[@]}; ++index)); do
    profile=${_BASHCLI_CONFIG_PROFILES[index]}
    _BASHCLI_CONFIG_PROFILE_PRIORITIES[${profile}]=${index}
  done
}

-bashcli-config-initialize-env() {
  local IFS line name

  if [ ${#_BASHCLI_CONFIG_ENV[@]} -gt 0 ]; then
    return 0
  fi

  while IFS= read -r line || [ -n "${line}" ]; do
    name=${line%%=*}
    if [[ ${name} != _* ]]; then
      _BASHCLI_CONFIG_ENV[${name}]=defined
    fi
  done < <(env)
}

-bashcli-config-check-property() {
  local property=$1
  if [[ ${property} != ${_BASHCLI_CONFIG_PROPERTY_PATTERN} ]]; then
    bashcli-error "invalid property name: ${property} (should match '${_BASHCLI_CONFIG_PROPERTY_PATTERN}')"
    return 1
  fi
}

-bashcli-config-check-profile() {
  local profile=$1
  if [[ ${profile} != ${_BASHCLI_CONFIG_PROFILE_PATTERN} ]]; then
    bashcli-error "invalid profile name: ${profile} (should match '${_BASHCLI_CONFIG_PROFILE_PATTERN}')"
    return 1
  fi
}

-bashcli-config-check-namespace() {
  local namespace=$1
  if [[ -z "${namespace}" || "${namespace}" == */* ]]; then
    bashcli-error "namespace must not be empty or contain slashes: ${namespace}"
    return 1
  fi
}

-bashcli-config-check-scope() {
  local scope=$1
  case ${scope} in
    default|global|local) ;;
    *) bashcli-error "invalid scope: ${scope} (should be one of default, local or global)"
       return 1
  esac
}

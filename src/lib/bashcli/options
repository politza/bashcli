#!/usr/bin/env bash

declare -gA _BASHCLI_OPTIONS_CONFIG_PROPERTIES=()

# Parses command options
#
# usage: COMMAND-NAME ... COMMAND-ARGS ...
bashcli-options-parse() {
  local _options _option _optionType _index _argument _arguments
  local _multiOptionRefPattern='__%s_ref' _multiOptionRef _multiOptionVar
  local -A _parsedOptions=()
  local _parsedParameters=()
  local -A _multiOptionRefs=()
  local -a _multiOptionVars=()
  local _commandMain _commandStack=("${_BASHCLI_COMMAND_STACK[@]}")
  local _definesSubcommands _configPropertyPrefix

  bashcli-debug "${_commandStack[*]}"

  if -bashcli-command-subcommands "${_commandStack[@]}"; then
    _definesSubcommands=true
  fi

  # Parse this functions arguments: OPTIONS-MAP PARAMETERS-ARRAY [ MULTI-OPTION-MAP ... ] -- ARGUMENTS
  for ((_index = 1; _index <= $# + 1; ++_index)); do
    if [ ${_index} -eq $(($# + 1)) ]; then
      bashcli-error "option separator (--) missing"
      return 1
    fi
    _argument="${!_index}"
    if [ "${_argument}" == '--' ]; then
      shift ${_index}
      break
    fi

    case ${_index} in
      1)
        if [ "${_argument}" ]; then
          if ! declare -p "${_argument}" | grep -q "^declare -[[:alpha:]]*A"; then
            bashcli-error "variable ${_argument} must be declared with the -A attribute"
            return 1
          fi
          unset _parsedOptions
          local -n _parsedOptions=${_argument}
        fi ;;
      2) if [ "${_argument}" ]; then
           unset _parsedParameters
           local -n _parsedParameters=${_argument}
         fi ;;
      *) _multiOptionVars+=("${_argument}") ;;
    esac
  done

  # Read command's context.
  -bashcli-context-clear
  if -bashcli-command-resolve "${_commandStack[@]}"; then
    _commandMain=${REPLY}
    -bashcli-context-read "${_commandStack[@]}"
  fi

  # Initialize the multi-option namerefs.
  for _multiOptionVar in "${_multiOptionVars[@]}"; do
    -bashcli-options-resolve-multivar "${_multiOptionVar}"
    _option=${REPLY}
    _multiOptionVar=${_multiOptionVar%%=*}
    printf -v _multiOptionRef "${_multiOptionRefPattern}" "${_multiOptionVar}"
    eval "local -n ${_multiOptionRef}=${_multiOptionVar}"
    _multiOptionRefs[${_option}]=${_multiOptionRef}
  done

  # Read configured options.
  -bashcli-options-from-config _parsedOptions _multiOptionRefs

  # Parse the options into the provided variables.
  while [ $# -gt 0 ]; do
    case $1 in
      --help)
        -bashcli-help-show "${_commandStack[@]}"
        exit 0 ;;
      --*=*)
        # Split long options with a value: --option=value .
        _arguments=("${1%%=*}" "${1#*=}")
        _option=${_arguments[0]#--}
        if [ "${_BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}" ]; then
          _option=${_BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}
        fi
        case ${_BASHCLI_CONTEXT_OPTIONS[${_option}]} in
          single|multi|multi-list) ;;
          *)
            bashcli-error "option does not accept arguments: ${_arguments[0]}" >&2
            return 1;;
        esac
        shift
        set --  "${_arguments[@]}" "$@"
        continue ;;
      -[^-]?*)
        # Split multiple concatenated short options with optional value, e.g. -abcVALUE .
        _arguments=()
        for ((_index = 1; _index < ${#1}; ++_index)); do
          _option=${1:_index:1}
          if [ "${_BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}" ]; then
            _option=${_BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}
          fi
          _optionType=${_BASHCLI_CONTEXT_OPTIONS[${_option}]}
          if [ -z "${_optionType}" ]; then
            bashcli-error "unrecognized option: -${_option}" >&2
            return 1
          fi
          if [ "${_option:1}" ]; then
            _arguments+=("--${_option}")
          else
            _arguments+=("-${_option}")
          fi
          case ${_optionType} in
            single|multi|multi-list)
              if [ $((_index + 1)) -lt ${#1} ]; then
                _arguments+=("${1:_index + 1}")
              fi
              break ;;
          esac
        done
        shift
        set -- "${_arguments[@]}" "$@"
        continue
        ;;
      --?*|-[^-])
        _option=${1#-}
        _option=${_option#-}
        if [ "${_BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}" ]; then
          _option=${_BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}
        fi
        if [[ "${_BASHCLI_CONTEXT_OPTIONS_SOURCE[${_option}]}" &&
                "${_BASHCLI_CONTEXT_OPTIONS_SOURCE[${_option}]}" != "${_commandMain}" ]]; then
          # Let subcommand options shadow their parent command's options.
          _parsedParameters+=("$1")
          case ${_BASHCLI_CONTEXT_OPTIONS[${_option}]} in
            single|multi|multi-list)
              if [ $# -gt 1 ]; then
                shift
                _parsedParameters+=("$1")
              fi ;;
          esac
        elif [ -n "${_BASHCLI_CONTEXT_OPTIONS[${_option}]}" ]; then
          _optionType=${_BASHCLI_CONTEXT_OPTIONS[${_option}]}
          case ${_optionType} in
            single|multi|multi-list)
              if [ $# -lt 2 ]; then
                bashcli-error "option requires an argument: $1" >&2
                return 1
              fi ;;
          esac
          case ${_optionType} in
            single)
              _parsedOptions[${_option}]=$2
              shift ;;
            multi|multi-list)
              if [ "${_optionType}" == multi-list ]; then
                bashcli-string-split "$2" , _arguments
              else
                _arguments=("$2")
              fi
              for _argument in "${_arguments[@]}"; do
                if [ -n "${_parsedOptions[${_option}]}" ]; then
                  _parsedOptions[${_option}]+=$'\n'
                fi
                _parsedOptions[${_option}]+=${_argument}
                if [ -R "${_multiOptionRefs[${_option}]}" ]; then
                  eval "${_multiOptionRefs[${_option}]}+=(\"${_argument}\")"
                fi
              done
              shift ;;
            flag)
              _parsedOptions[${_option}]=true ;;
            enum:?*)
              _parsedOptions[${_optionType#enum:}]=${_option} ;;
            *)
              bashcli-error "invalid option type: ${_optionType}"
              return 1;;
          esac
        else
          bashcli-error "unrecognized option: $1" >&2
          return 1
        fi ;;
      --)
        if [ "${_definesSubcommands}" != true ]; then
          shift
        fi
        _parsedParameters+=("$@")
        break ;;
      *)
        # Assume the non-option argument is a possible subcommand.
        if [ "${_definesSubcommands}" == true ] &&
             [ "$1" ] &&
             -bashcli-command-resolve "${_commandStack[@]}" "$1" &>/dev/null; then
          _commandStack+=("$1")
          -bashcli-context-read "${_commandStack[@]}"
        fi
        _parsedParameters+=("$1")
    esac
    shift
  done

  bashcli-debug "parsed ${#_parsedOptions[@]} options and ${#_parsedParameters[@]} parameters"
}

-bashcli-options-resolve-multivar() {
  local option optionType

  if [[ $1 == *=* ]]; then
    option=${1#*=}
    optionType="${_BASHCLI_CONTEXT_OPTIONS[${option}]}"
  else
    return 1
  fi

  REPLY=
  case ${optionType} in
    multi|multi-list)
      REPLY="${option}" ;;
    *)
      if [ -n "${optionType}" ]; then
        bashcli-error "matched variable $1 with non-multi option ${option}"
      else
        bashcli-error "failed to match variable $1 with any options"
      fi
      return 1 ;;
  esac
}

-bashcli-options-aliases() {
  local option=$1 alias aliasedOption
  local IFS=$'\n'

  REPLY=()
  for alias in "${!_BASHCLI_CONTEXT_OPTION_ALIASES[@]}"; do
    aliasedOption=${_BASHCLI_CONTEXT_OPTION_ALIASES[${alias}]}
    if [ "${option}" == "${aliasedOption}" ]; then
      REPLY+=("${alias}")
    fi
  done
  if [ ${#REPLY[@]} -gt 0 ]; then
    readarray -t REPLY <<<"$(LC_ALL=C sort <<<"${REPLY[*]}")"
  fi
}

-bashcli-options-from-config() {
  local -n __options=$1
  local -n __multiOptionRefs=$2
  local IFS=.
  local __propertyBase="${_BASHCLI_COMMAND_STACK[*]:1}"
  local __configReadOptions __option __property __optionType
  unset IFS

  case ${#_BASHCLI_COMMAND_STACK[@]} in
    1) return 0;;
    2) __configReadOptions=(-p "${BASHCLI_CLI_NAME}" -p "${_BASHCLI_COMMAND_STACK[1]}")
       bashcli-config-read "${__configReadOptions[@]}"
  esac

  for __option in "${!_BASHCLI_CONTEXT_OPTIONS[@]}"; do
    __property=${__option}
    __optionType=${_BASHCLI_CONTEXT_OPTIONS[${__option}]}

    if [ "${__propertyBase}" ]; then
      __property=${__propertyBase}.${__property}
    fi

    case ${__optionType} in
      flag)
        if bashcli-config-get -x -t boolean "${__property}" && [ "${REPLY}" == true ]; then
          __options[${__option}]=true
        fi;;
      single)
        if bashcli-config-get -x "${__property}"; then
          __options[${__option}]=${REPLY}
        fi;;
      multi|multi-list)
        if bashcli-config-get -x -t array "${__property}"; then
          IFS=$'\n'
          __options[${__option}]=${REPLY[*]}
          unset IFS
          if [ "${__multiOptionRefs[${__option}]}" ]; then
            eval "${_multiOptionRefs[${_option}]}+=(\"\${REPLY[@]}\")"
          fi
        fi;;
    esac
  done
}

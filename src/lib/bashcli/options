#!/usr/bin/env bash

# shellcheck disable=SC2215,SC2165,SC2167,SC2004,SC2059
bashcli-options-parse() {
  local _options _option _optionType _index _argument _arguments
  local _multiOptionRefPattern='__%s_ref' _multiOptionRef _multiOptionVar
  local -n _parsedOptions _parsedParameters
  local -A _multiOptionRefs=()
  local -a _multiOptionVars=()
  local _commandDir _subcommandDir _commandStack=("${BASHCLI_COMMAND_STACK[@]}")
  local _definesSubcommands

  if bashcli-command-defines-subcommands "${_commandStack[@]}"; then
    _definesSubcommands=true
  fi

  # Parse this functions arguments: OPTIONS-MAP PARAMETERS-ARRAY [ MULTI-OPTION-MAP ... ] -- ARGUMENTS
  for ((_index = 1; _index <= $# + 1; ++_index)); do
    if [ ${_index} -eq $(($# + 1)) ]; then
      bashcli-error "Option separator (--) missing"
      return 1
    fi
    _argument="${!_index}"
    if [ "${_argument}" == '--' ]; then
      shift ${_index}
      break
    fi

    case ${_index} in
      1)
        if ! declare -p "${_argument}" | grep -q "^declare -[[:alpha:]]*A"; then
          bashcli-error "Variable ${_argument} must be declared with the -A attribute"
          return 1
        fi
        _parsedOptions=${_argument} ;;
      2) _parsedParameters=${_argument} ;;
      *) _multiOptionVars+=("${_argument}") ;;
    esac
  done

  # Read command's context.
  bashcli-context-clear
  if bashcli-command-resolve "${_commandStack[@]}"; then
    _commandDir=${REPLY}
    bashcli-context-read "${_commandDir}"
  fi

  # Initialize the multi-option namerefs.
  for _multiOptionVar in "${_multiOptionVars[@]}"; do
    -bashcli-options-resolve-multivar "${_multiOptionVar}" || return 1
    _option=${REPLY}
    _multiOptionVar=${_multiOptionVar%%=*}
    printf -v _multiOptionRef "${_multiOptionRefPattern}" "${_multiOptionVar}"
    eval "local -n ${_multiOptionRef}=${_multiOptionVar}" || return 1
    _multiOptionRefs[${_option}]=${_multiOptionRef}
  done

  # Parse the options into the provided variables.
  while [ $# -gt 0 ]; do
    case $1 in
      --help)
        bashcli-help-show "${_commandStack[@]}"
        exit 0 ;;
      --*=*)
        # Split long options with a value: --option=value .
        _arguments=("${1%%=*}" "${1#*=}")
        _option=${_arguments[0]#--}
        if [ "${BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}" ]; then
          _option=${BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}
        fi
        case ${BASHCLI_CONTEXT_OPTIONS[${_option}]} in
          single|multi) ;;
          *) printf "%s\n" "${BASHCLI_COMMAND_STACK[*]}: option does not accept arguments: ${_arguments[0]}" >&2
             exit 1;;
        esac
        shift
        set --  "${_arguments[@]}" "$@"
        continue ;;
      -[^-]?*)
        # Split multiple concatenated short options with a possible value: -abcVALUE .
        _arguments=()
        for ((_index = 1; _index < ${#1}; ++_index)); do
          _option=${1:_index:1}
          if [ "${BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}" ]; then
            _option=${BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}
          fi
          _optionType=${BASHCLI_CONTEXT_OPTIONS[${_option}]}
          if [ -z "${_optionType}" ]; then
            printf "%s\n" "${_commandStack[*]}: unrecognized option: -${_option}" >&2
            exit 1
          fi
          _arguments+=("-${_option}")
          case ${_optionType} in
            single|multi)
              _arguments+=("${1:_index + 1}")
              break ;;
          esac
        done
        shift
        set -- "${_arguments[@]}" "$@"
        continue
        ;;
      --?*|-[^-]) _option=${1#-}
          _option=${_option#-}
          if [ "${BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}" ]; then
            _option=${BASHCLI_CONTEXT_OPTION_ALIASES[${_option}]}
          fi
          if [[ "${BASHCLI_CONTEXT_OPTIONS_SOURCE[${_option}]}" &&
                  "${BASHCLI_CONTEXT_OPTIONS_SOURCE[${_option}]}" != "${_commandDir}" ]]; then
            # Let subcommand options shadow their parent command's options.
            _parsedParameters+=("$1")
            case ${BASHCLI_CONTEXT_OPTIONS[${_option}]} in
              single|multi)
                if [ $# -gt 1 ]; then
                  shift
                  _parsedParameters+=("$1")
                fi ;;
            esac
          elif [ -n "${BASHCLI_CONTEXT_OPTIONS[${_option}]}" ]; then
            _optionType=${BASHCLI_CONTEXT_OPTIONS[${_option}]}
            case ${_optionType} in
              single|multi)
                if [ $# -lt 2 ]; then
                  printf "%s\n" "${BASHCLI_COMMAND_STACK[*]}: option requires an argument: $1" >&2
                  exit 1
                fi ;;
            esac
            case ${_optionType} in
              single)
                _parsedOptions[${_option}]=$2
                shift ;;
              multi)
                if [ -n "${_parsedOptions[${_option}]}" ]; then
                  _parsedOptions[${_option}]+=$'\n'
                fi
                _parsedOptions[${_option}]+=$2
                if [ -R "${_multiOptionRefs[${_option}]}" ]; then
                  eval "${_multiOptionRefs[${_option}]}+=(\"$2\")" || return 1
                fi
                shift ;;
              boolean)
                _parsedOptions[${_option}]=true ;;
              enum:?*)
                _parsedOptions[${_optionType#enum:}]=${_option} ;;
              *)
                bashcli-fatal "Internal error" ;;
            esac
          else
            printf "%s\n" "${_commandStack[*]}: unrecognized option: $1" >&2
            exit 1
          fi ;;
      --)
        if [ "${_definesSubcommands}" != true ]; then
          shift
        fi
        _parsedParameters+=("$@")
        break ;;
      *)
        # Assume the non-option argument is a possible subcommand.
        if [ "${_definesSubcommands}" == true ] &&
             [ "$1" ] &&
             bashcli-command-resolve "${_commandStack[@]}" "$1" &>/dev/null; then
          _subcommandDir=${REPLY}
          _commandStack+=("$1")
          bashcli-context-read "${_subcommandDir}"
        fi
        _parsedParameters+=("$1")
    esac
    shift
  done
}

-bashcli-options-resolve-multivar() {
  local option optionType

  if [[ $1 == *=* ]]; then
    option=${1#*=}
    optionType="${BASHCLI_CONTEXT_OPTIONS[${option}]}"
  else
    return 1
  fi

  REPLY=
  case ${optionType} in
    multi)
      bashcli-debug "$1 -> ${option}"
      REPLY="${option}" ;;
    *)
      if [ -n "${optionType}" ]; then
        bashcli-error "Matched variable $1 with non-multi option ${option}"
      else
        bashcli-error "Failed to match variable $1 with any options"
      fi
      return 1 ;;
  esac
}

bashcli-option-aliases() {
  local option=$1 alias aliasedOption

  REPLY=()
  for alias in "${!BASHCLI_CONTEXT_OPTION_ALIASES[@]}"; do
    aliasedOption=${BASHCLI_CONTEXT_OPTION_ALIASES[${alias}]}
    if [ "${option}" == "${aliasedOption}" ]; then
      REPLY+=("${alias}")
    fi
  done
}

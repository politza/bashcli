#!/usr/bin/env bash

declare -g -a BASHCLI_COMMAND_DIRS=(
  "${BASHCLI_USER_DIR}/commands"
  "${BASHCLI_CLI_DIR}/commands"
)

if ! [ "${BASHCLI_DIR}/commands" -ef "${BASHCLI_CLI_DIR}/commands" ]; then
  BASHCLI_COMMAND_DIRS+=("${BASHCLI_DIR}/commands")
fi

declare -g -a BASHCLI_COMMAND_STACK=()
declare -g -a BASHCLI_COMMAND_NEXT=()
declare -g BASHCLI_COMMAND_PATTERN='?(.|+([a-zA-Z0-9_-]))'
declare -g BASHCLI_COMMAND_MAIN=@main
declare -g -A BASHCLI_COMMAND_RESOLVE_CACHE=()

bashcli-command-resolve() {
  local commandList=("$@")
  local IFS=/
  local commandPath="${commandList[*]}"
  local round commandName commandDir commandFile commandMain
  REPLY=()

  if [ ${#commandList[@]} -eq 0 ]; then
    bashcli-error "command-list is empty"
    return 1
  fi

  if [ "${BASHCLI_COMMAND_RESOLVE_CACHE[${commandList[*]}]}" ]; then
    eval "REPLY=(${BASHCLI_COMMAND_RESOLVE_CACHE[${commandList[*]}]})"
    return 0
  fi

  bashcli-debug "resolving ${commandPath}"

  for commandName in "${commandList[@]}"; do
    bashcli-command-check-name "${commandName}"
  done

  commandName=${BASHCLI_COMMAND_MAIN}

  for ((round = 0; round < 2; ++round)); do
    for commandDir in "${BASHCLI_COMMAND_DIRS[@]}"; do
      commandMain=${commandPath}/${commandName}
      commandFile=${commandDir}/${commandMain}
      if [ -f "${commandFile}" ]; then
        bashcli-debug "${commandList[*]} -> ${commandFile}"
        REPLY=("${commandFile}" "${commandMain}")
        bashcli-string-quote commandFile commandMain
        BASHCLI_COMMAND_RESOLVE_CACHE[${commandList[*]}]="${commandFile} ${commandMain}"
        return 0
      fi
    done

    if [ ${#commandList[@]} -gt 1 ]; then
      commandName=${commandPath##*/}
      commandPath=${commandPath%/*}
    else
      break
    fi
  done

  IFS=' '
  bashcli-error "no such command: ${commandList[*]:1} (try the --help option)"
  return 1
}

bashcli-command-exec() {
  if [ -z "$1" ]; then
      bashcli-error "no command given (try the --help option)"
  fi

  if [ ${#BASHCLI_COMMAND_NEXT[@]} -gt 0 ]; then
    bashcli-fatal "command already pending execution, try bashcli-command-exec-now"
  fi
  BASHCLI_COMMAND_NEXT=("$@")
}

bashcli-command-exec-next() {
  set -- "${BASHCLI_COMMAND_NEXT[@]}"
  if [ $# -eq 0 ]; then
    bashcli-error "no command pending execution"
    return 1
  fi
  BASHCLI_COMMAND_NEXT=()
  bashcli-command-exec-now "$@"
}

bashcli-command-exec-now() {
  local command=$1
  local commandList=("${BASHCLI_COMMAND_STACK[@]}" "${command}")
  shift

  if [ -z "${command}" ]; then
    bashcli-error "no command given (try the --help option)"
    return 1
  fi

  bashcli-debug "preparing ${commandList[*]}"
  bashcli-command-resolve "${commandList[@]}"
  BASHCLI_COMMAND_STACK+=("${command}")
  -bashcli-command-local-unset command commandList
  bashcli-debug "executing ${REPLY[0]}"
  . "${REPLY}" "$@"
}

bashcli-command-subcommands() {
  bashcli-command-resolve "$@"

  local commandPath=${REPLY[1]%/*}
  local commandMain=${REPLY[1]##*/}
  local -A subcommands=()
  local commandRootDir subcommandMain subcommandName commandDir
  local IFS
  REPLY=()

  if [ "${commandMain}" != "${BASHCLI_COMMAND_MAIN}" ]; then
    return 1
  fi

  for commandRootDir in "${BASHCLI_COMMAND_DIRS[@]}"; do
    commandDir=${commandRootDir}/${commandPath}
    if [ -d "${commandDir}" ]; then
      for subcommandMain in "${commandDir}"/*; do
        if [ -f "${subcommandMain}" ] || [ -f "${subcommandMain}/${BASHCLI_COMMAND_MAIN}" ]; then
          subcommandName=${subcommandMain##*/}
          if [[ "${subcommandName}" == ${BASHCLI_COMMAND_PATTERN} ]]; then
            subcommands["${subcommandName}"]=1
          fi
        fi
      done
    fi
  done

  bashcli-debug "$* -> ${!subcommands[*]}"
  IFS=$'\n'
  REPLY=($(LC_ALL=C sort <<<"${!subcommands[@]}"))
  [ ${#REPLY} -gt 0 ]
}

-bashcli-command-local-unset() {
  unset "$@"
}

bashcli-command-check-name() {
  if [[ "$1" != ${BASHCLI_COMMAND_PATTERN} ]]; then
    bashcli-error "invalid command name: $1"
    return 1
  fi
}

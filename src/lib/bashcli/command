#!/usr/bin/env bash
#shellcheck disable=SC2215,SC2053

declare -g -a BASHCLI_COMMAND_ROOTS=(
  "${XDG_CONFIG_HOME:-$HOME/.config}/${BASHCLI_CLI_NAME}/commands"
  "${BASHCLI_CLI_DIR}/commands"
  "${BASHCLI_DIR}/commands"
)
declare -g -a BASHCLI_COMMAND_STACK=()
declare -g -a BASHCLI_COMMAND_NEXT=()
declare -g BASHCLI_COMMAND_PATTERN='?(.|+([^.@]))'
declare -g BASHCLI_COMMAND_MAIN=@main

# shellcheck disable=SC2059
bashcli-command-resolve() {
  local commandList=("$@")
  local IFS=/
  local commandPath="${commandList[*]}"
  local round commandName commandRoot commandMain
  REPLY=()

  if [ ${#commandList[@]} -eq 0 ]; then
    bashcli-error "command-list is empty"
    return 1
  fi

  for commandName in "${commandList[@]}"; do
    if [[ "${commandName}" != ${BASHCLI_COMMAND_PATTERN} ]]; then
      bashcli-error "invalid command name: ${commandName}"
      return 1
    fi
  done

  commandName=${BASHCLI_COMMAND_MAIN}

  for ((round = 0; round < 2; ++round)); do
    for commandRoot in "${BASHCLI_COMMAND_ROOTS[@]}"; do
      commandMain=${commandRoot}/${commandPath}/${commandName}
      if [ -f "${commandMain}" ]; then
        REPLY=("${commandMain}" "${commandPath}/${commandName}")
        return 0
      fi
    done

    if [ ${#commandList[@]} -gt 1 ]; then
      commandName=${commandPath##*/}
      commandPath=${commandPath%/*}
    else
      break
    fi
  done

  IFS=' '
  bashcli-error "no such command: ${commandList[*]:1} (try ${BASHCLI_CLI_NAME:-bashcli} --help)"
  return 1
}

bashcli-command-exec() {
  if [ ${#BASHCLI_COMMAND_NEXT[@]} -gt 0 ]; then
    bashcli-fatal "command already pending for execution, try bashcli-command-exec-now"
  fi
  BASHCLI_COMMAND_NEXT=("$@")
}

bashcli-command-exec-next() {
  set -- "${BASHCLI_COMMAND_NEXT[@]}"
  if [ $# -eq 0 ]; then
    bashcli-error "no command pending for execution"
    return 1
  fi
  BASHCLI_COMMAND_NEXT=()
  bashcli-command-exec-now "$@"
}

bashcli-command-exec-now() {
  local command=$1
  local commandList=("${BASHCLI_COMMAND_STACK[@]}" "${command}")
  shift

  if [ -z "${command}" ]; then
    bashcli-error "no command given"
    return 1
  fi

  bashcli-command-resolve "${commandList[@]}" || return 1
  bashcli-debug "${commandList[*]} -> ${REPLY}"

  BASHCLI_COMMAND_STACK+=("${command}")
  -bashcli-command-local-unset command commandList
  # shellcheck source=/dev/null
  . "${REPLY[0]}" "$@"
}

bashcli-command-subcommands() {
  bashcli-command-resolve "$@" || return 1

  local commandPath=${REPLY[1]%/*}
  local commandMain=${REPLY[1]##*/}
  local -A subcommands=()
  local commandRoot subcommandMain subcommandName commandDir
  REPLY=()

  if [ "${commandMain}" != "${BASHCLI_COMMAND_MAIN}" ]; then
    return 1
  fi

  for commandRoot in "${BASHCLI_COMMAND_ROOTS[@]}"; do
    commandDir=${commandRoot}/${commandPath}
    if [ -d "${commandDir}" ]; then
      for subcommandMain in "${commandDir}"/*; do
        if [ -f "${subcommandMain}" ] || [ -f "${subcommandMain}/${BASHCLI_COMMAND_MAIN}" ]; then
          subcommandName=${subcommandMain##*/}
          if [[ "${subcommandName}" == ${BASHCLI_COMMAND_PATTERN} ]]; then
            subcommands["${subcommandName}"]=1
          fi
        fi
      done
    fi
  done

  bashcli-debug "$* -> ${!subcommands[*]}"
  REPLY=("${!subcommands[@]}")
  [ ${#REPLY} -gt 0 ]
}

-bashcli-command-local-unset() {
  unset "$@"
}

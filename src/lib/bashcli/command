#!/usr/bin/env bash

declare -g _BASHCLI_USER_DIR="${XDG_CONFIG_HOME:-${HOME}/.config}/${BASHCLI_CLI_NAME}"
declare -g -a _BASHCLI_COMMAND_DIRS=(
  "${_BASHCLI_USER_DIR}/commands"
  "${BASHCLI_CLI_DIR}/commands"
)

if ! [ "${BASHCLI_DIR}/commands" -ef "${BASHCLI_CLI_DIR}/commands" ]; then
  _BASHCLI_COMMAND_DIRS+=("${BASHCLI_DIR}/commands")
fi

declare -g -a _BASHCLI_COMMAND_STACK=()
declare -g -a _BASHCLI_COMMAND_NEXT=()
declare -g _BASHCLI_COMMAND_PATTERN='?(.|+([a-zA-Z0-9_-]))'
declare -g _BASHCLI_COMMAND_MAIN=@main
declare -g -A _BASHCLI_COMMAND_RESOLVE_CACHE=()

# Executes a subcommand of the current one.
#
# This function is typically used as the last statment in a non-terminal bashcli command with the
# remaining arguments of the initial command-line.
#
# Note, that command is not executed immediately, but in a different context. The reason for this is
# to avoid inheriting variables from a parent- to its child-commands.
#
# As a consequence, the exit-status of this function is not meaningful and usually always zero; and
# this function can be invoked only once during a single command invocation.
#
# Use bashcli-exec to execute a bashcli command in a standard way.
#
# usage: COMMAND-NAME ... COMMAND-ARGS ...
bashcli-command-exec() {
  if [ -z "$1" ]; then
    bashcli-error "no command given (try the --help option)"
  fi

  if [ ${#_BASHCLI_COMMAND_NEXT[@]} -gt 0 ]; then
    bashcli-fatal "command already pending execution"
  fi
  _BASHCLI_COMMAND_NEXT=("$@")
}

-bashcli-command-resolve() {
  local commandList=("$@")
  local IFS=/
  local commandPath="${commandList[*]}"
  local round commandName commandDir commandFile commandMain
  REPLY=()

  if [ ${#commandList[@]} -eq 0 ]; then
    bashcli-error "command-list is empty"
    return 1
  fi

  if [ "${_BASHCLI_COMMAND_RESOLVE_CACHE[${commandList[*]}]}" ]; then
    eval "REPLY=(${_BASHCLI_COMMAND_RESOLVE_CACHE[${commandList[*]}]})"
    return 0
  fi

  bashcli-debug "resolving ${commandPath}"

  for commandName in "${commandList[@]}"; do
    -bashcli-command-check-name "${commandName}"
  done

  commandName=${_BASHCLI_COMMAND_MAIN}

  for ((round = 0; round < 2; ++round)); do
    for commandDir in "${_BASHCLI_COMMAND_DIRS[@]}"; do
      commandMain=${commandPath}/${commandName}
      commandFile=${commandDir}/${commandMain}
      if [ -f "${commandFile}" ]; then
        bashcli-debug "${commandList[*]} -> ${commandFile}"
        REPLY=("${commandFile}" "${commandMain}")
        bashcli-string-quote commandFile commandMain
        _BASHCLI_COMMAND_RESOLVE_CACHE[${commandList[*]}]="${commandFile} ${commandMain}"
        return 0
      fi
    done

    if [ ${#commandList[@]} -gt 1 ]; then
      commandName=${commandPath##*/}
      commandPath=${commandPath%/*}
    else
      break
    fi
  done

  IFS=' '
  bashcli-error "no such command: ${commandList[*]:1} (try the --help option)"
  return 1
}

-bashcli-command-loop() {
  -bashcli-command-exec-now "$@"
  while [ ${#_BASHCLI_COMMAND_NEXT[@]} -gt 0 ]; do
    -bashcli-command-exec-next
  done
}

-bashcli-command-exec-next() {
  set -- "${_BASHCLI_COMMAND_NEXT[@]}"
  if [ $# -eq 0 ]; then
    bashcli-error "no command pending execution"
    return 1
  fi
  _BASHCLI_COMMAND_NEXT=()
  -bashcli-command-exec-now "$@"
}

-bashcli-command-exec-now() {
  local command=$1
  local commandList=("${_BASHCLI_COMMAND_STACK[@]}" "${command}")
  shift

  if [ -z "${command}" ]; then
    bashcli-error "no command given (try the --help option)"
    return 1
  fi

  bashcli-debug "preparing ${commandList[*]}"
  -bashcli-command-resolve "${commandList[@]}"
  _BASHCLI_COMMAND_STACK+=("${command}")
  -bashcli-command-local-unset command commandList
  bashcli-debug "executing ${REPLY[0]}"
  . "${REPLY}" "$@"
}

-bashcli-command-subcommands() {
  -bashcli-command-resolve "$@"

  local commandPath=${REPLY[1]%/*}
  local commandMain=${REPLY[1]##*/}
  local -A subcommands=()
  local commandRootDir subcommandMain subcommandName commandDir
  local IFS
  REPLY=()

  if [ "${commandMain}" != "${_BASHCLI_COMMAND_MAIN}" ]; then
    return 1
  fi

  for commandRootDir in "${_BASHCLI_COMMAND_DIRS[@]}"; do
    commandDir=${commandRootDir}/${commandPath}
    if [ -d "${commandDir}" ]; then
      for subcommandMain in "${commandDir}"/*; do
        if [ -f "${subcommandMain}" ] || [ -f "${subcommandMain}/${_BASHCLI_COMMAND_MAIN}" ]; then
          subcommandName=${subcommandMain##*/}
          if [[ "${subcommandName}" == ${_BASHCLI_COMMAND_PATTERN} ]]; then
            subcommands["${subcommandName}"]=1
          fi
        fi
      done
    fi
  done

  bashcli-debug "$* -> ${!subcommands[*]}"
  IFS=$'\n'
  REPLY=($(LC_ALL=C sort <<<"${!subcommands[@]}"))
  [ ${#REPLY} -gt 0 ]
}

-bashcli-command-local-unset() {
  unset "$@"
}

-bashcli-command-check-name() {
  if [[ "$1" != ${_BASHCLI_COMMAND_PATTERN} ]]; then
    bashcli-error "invalid command name: $1"
    return 1
  fi
}

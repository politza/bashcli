#!/usr/bin/env bash
#shellcheck disable=SC2215

declare -g -a BASHCLI_COMMAND_ROOTS=(
  "${XDG_CONFIG_HOME:-$HOME/.config}/${BASHCLI_CLI_NAME}/commands"
  "${BASHCLI_CLI_DIR}/commands"
  "${BASHCLI_DIR}/commands"
)
declare -g -a BASHCLI_COMMAND_STACK=()
declare -g -a BASHCLI_COMMAND_NEXT=()

bashcli-command-resolve() {
  local commandList=("$@")
  local IFS=/
  local commandPath="${commandList[*]:1}"
  local commandRoot commandDir
  unset IFS
  REPLY=()

  for commandRoot in "${BASHCLI_COMMAND_ROOTS[@]}"; do
    commandDir=${commandRoot}
    if [ "${commandPath}" ]; then
      commandDir+=/${commandPath}
    fi
    if [ -f "${commandDir}"/main ]; then
      bashcli-debug "${commandList[*]} -> ${commandDir}"
      REPLY=("${commandDir}" "${commandRoot}" "${commandPath}")
      return 0
    fi
  done

  bashcli-error "no such command: ${commandList[*]}"
  return 1
}

bashcli-command-exec() {
  if [ ${#BASHCLI_COMMAND_NEXT[@]} -gt 0 ]; then
    bashcli-fatal "command already pending for execution, try bashcli-command-exec-now"
  fi
  BASHCLI_COMMAND_NEXT=("$@")
}

bashcli-command-exec-next() {
  set -- "${BASHCLI_COMMAND_NEXT[@]}"
  if [ $# -eq 0 ]; then
    bashcli-error "no command pending for execution"
    return 1
  fi
  BASHCLI_COMMAND_NEXT=()
  bashcli-command-exec-now "$@"
}

bashcli-command-exec-now() {
  local command=$1
  local commandList=("${BASHCLI_COMMAND_STACK[@]}" "${command}")
  shift

  if [ -z "${command}" ]; then
    bashcli-error "no command given"
    return 1
  fi

  bashcli-debug "${commandList[*]}"
  bashcli-command-resolve "${commandList[@]}" || return 1

  BASHCLI_COMMAND_STACK+=("${command}")
  -bashcli-command-local-unset command commandList
  # shellcheck source=/dev/null
  . "${REPLY[0]}"/main "$@"
}

bashcli-command-subcommands() {
  bashcli-command-resolve "$@" || return 1

  local commandDir=${REPLY[0]}
  local commandPath=${REPLY[2]}
  local -A subcommands=()
  local commandRoot subcommand subcommandDir
  REPLY=()

  # Check if the command defines subcommands on its own.
  for subcommand in "${commandDir}"/*/main; do
    if [ -f "${subcommand}" ]; then
      break;
    fi
    subcommand=
  done

  if [ -z "${subcommand}" ]; then
    return 0
  fi

  for commandRoot in "${BASHCLI_COMMAND_ROOTS[@]}"; do
    commandDir=${commandRoot}/${commandPath}
    if [ -d "${commandDir}" ]; then
      for subcommandDir in "${commandDir}"/*; do
        if [ -f "${subcommandDir}"/main ]; then
          subcommands["${subcommandDir##*/}"]=present
        fi
      done
    fi
  done
  REPLY=("${!subcommands[@]}")
}

-bashcli-command-local-unset() {
  unset "$@"
}

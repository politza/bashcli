#!/usr/bin/env bash

declare -g -A _BASHCLI_HELP_FACES=(
  bold $'\033[1m'
  regular $'\033[0m'
)
declare -g _BASHCLI_HELP_MAX_PARAMETERS=8

if ! [ -t 1 ]; then
  _BASHCLI_HELP_FACES=()
fi

declare -g _BASHCLI_HELP_WIDTH=$(( ${COLUMNS:-80} < 80 ? ${COLUMNS:-80} : 80))

-bashcli-help-show() {
  local commandList=("$@")
  local commandMain

  trap "$(shopt -p extglob)" EXIT RETURN
  shopt -s extglob

  bashcli-debug "${commandList[*]}"
  -bashcli-command-resolve "${commandList[@]}"
  commandMain=${REPLY}
  -bashcli-context-clear
  -bashcli-context-read "${commandList[@]}"

  -bashcli-help-show-intro "${commandMain}" "${commandList[@]}"
  -bashcli-help-show-options
  -bashcli-help-show-subcommands "${commandList[@]}"
}

-bashcli-help-show-intro() {
  local commandMain=$1
  shift
  local commandList=("$@")
  local description=${_BASHCLI_CONTEXT_DESCRIPTIONS[${commandMain}]}
  local parameter parameterInfo parameterIndex parameterCount

  bashcli-string-trim description

  # Determine the maximum n of parameter-n value-types.
  for parameter in "${!_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[@]}"; do
    if [[ ${parameter} == %parameter-+([0-9]) ]]; then
      parameterIndex=${parameter##%parameter?}
      if [ "${parameterIndex}" -ge ${_BASHCLI_HELP_MAX_PARAMETERS} ]; then
        bashcli-warn "max parameter count exceeded: ${_BASHCLI_HELP_MAX_PARAMETERS}"
        parameterCount=0
        break
      fi
      ((parameterCount = parameterIndex + 1 > parameterCount ? parameterIndex + 1 : parameterCount))
    fi
  done

  if [ "${_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter]}" ]; then
      ((++parameterCount))
  fi

  for ((parameterIndex = 0; parameterIndex < parameterCount; ++parameterIndex)); do
    parameterType=${_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter-${parameterIndex}]}
    if [ -z "${parameterType}" ]; then
      parameterType=${_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter]:-parameter}
    fi
    parameterInfo+=" ${parameterType^^}"
  done

  if [ "${_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[%parameter]}" ]; then
    parameterInfo+=' ...'
  fi

  commandList[0]=${BASHCLI_CLI_NAME}
  printf "%sUsage:%s\n%s [ OPTIONS ]%s\n" "${_BASHCLI_HELP_FACES[bold]}" "${_BASHCLI_HELP_FACES[regular]}" \
         "${commandList[*]}" "${parameterInfo}"
  if [ -n "${description}" ]; then
    fmt --width "${_BASHCLI_HELP_WIDTH}" <<<$'\n'"${description%%*($'\n')}"
  fi
}

-bashcli-help-show-options() {
  local -A optionLabels=()
  local index optionDashes option optionAliases optionVariants optionVariant
  local optionValueType optionType optionLabel description
  local options

  -bashcli-help-sorted-options
  options=("${REPLY[@]}")

  for option in "${options[@]}"; do
    # Accumulate options and their aliases as variants and add dash-prefixes.
    -bashcli-options-aliases "${option}"
    optionAliases=("${REPLY[@]}")
    optionVariants=("${option}" "${optionAliases[@]}")
    for ((index = 0; index < ${#optionVariants[@]}; ++index)); do
      optionVariant=${optionVariants[${index}]}
      optionDashes=${optionVariant:0:2}
      optionDashes=${optionDashes//?/-}
      optionVariants[${index}]=${optionDashes}${optionVariant}
    done

    # Build the label starting with variants, then add their value type and store the result.
    optionLabel=
    for ((index = 0; index < ${#optionVariants[@]}; ++index)); do
      if [ ${index} -gt 0 ]; then
        optionLabel+=', '
      fi
      optionLabel+=${optionVariants[${index}]}
    done

    optionType=${_BASHCLI_CONTEXT_OPTIONS[${option}]}
    case ${optionType} in
      single|multi|multi-list)
        optionValueType=${_BASHCLI_CONTEXT_OPTION_VALUE_TYPES[${option}]:-OPTION}
        optionValueType=${optionValueType//,/ | }
        optionLabel+=" ${optionValueType^^}"
    esac
    optionLabels[${option}]=${optionLabel}
  done

  # Now print the options with their description.
  if [ ${#optionLabels[@]} -gt 0 ]; then
    printf "\n%sOptions:%s\n" "${_BASHCLI_HELP_FACES[bold]}" "${_BASHCLI_HELP_FACES[regular]}"
    for ((index = 0; index < ${#options[@]}; ++index)); do
      option=${options[index]}
      if [ ${index} -gt 0 ]; then
        echo
      fi
      printf "%s\n" "${optionLabels[${option}]}"
      description=${_BASHCLI_CONTEXT_OPTION_DESCRIPTIONS[${option}]}
      bashcli-string-trim description
      fmt --width "$((${_BASHCLI_HELP_WIDTH} - 2))"  <<< "${description%%*($'\n')}" | pr --indent 2 --omit-pagination
    done
  fi
}

-bashcli-help-show-subcommands() {
  local commandList=("$@")
  local maxSubcommandLength=0
  local padding=4
  local subcommand subcommand description

  if -bashcli-command-subcommands "${commandList[@]}"; then
    printf "\n%sSubcommands:%s\n" "${_BASHCLI_HELP_FACES[bold]}" "${_BASHCLI_HELP_FACES[regular]}"

    for subcommand in "${REPLY[@]}"; do
      if [ ${#subcommand} -gt "${maxSubcommandLength}" ]; then
        maxSubcommandLength=${#subcommand}
      fi
    done

    ((maxSubcommandLength += padding))
    for subcommand in "${REPLY[@]}"; do
      -bashcli-command-resolve "${commandList[@]}" "${subcommand}"
      commandMain=${REPLY}
      if [ -n "${commandMain}" ]; then
        -bashcli-context-read "${commandList[@]}" "${subcommand}"
      fi
      description=${_BASHCLI_CONTEXT_DESCRIPTIONS[${commandMain}]}
      bashcli-string-trim description
      printf "%-${maxSubcommandLength}s%s\n" "${subcommand}" "${description%%$'\n'*}"
    done
  fi
}

-bashcli-help-sorted-options() {
  local index option default
  local IFS=$'\n'
  local options=($(LC_ALL=C sort <<<"${!_BASHCLI_CONTEXT_OPTIONS[@]}"))
  REPLY=()

  for ((index = 0; index < ${#options[@]}; ++index)); do
    option=${options[index]}
    for default in "${_BASHCLI_CONTEXT_DEFAULT_OPTIONS[@]}"; do
      if [ "${option}" == "${default}" ]; then
        break
      fi
      default=
    done
    if [ -z "${default}" ]; then
      REPLY+=("${option}")
    fi
  done
  for option in "${_BASHCLI_CONTEXT_DEFAULT_OPTIONS[@]}"; do
    if [ "${_BASHCLI_CONTEXT_OPTIONS[${option}]}" ]; then
      REPLY+=("${option}")
    fi
  done
}

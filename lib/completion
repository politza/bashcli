#!/usr/bin/env bash

# shellcheck disable=SC2155,SC2128
bashcli-completion-complete() {
  # shellcheck disable=SC2034
  local cur prev words cword comp_args
  local -A BASHCLI_COMPLETIONS=()
  local commandStack=()
  local index option word subcommand completion completionFn completionFns

  # shellcheck disable=SC2153
  if ! [[ -d "${BASHCLI_DIR}" && -n "${BASHCLI_CLI_NAME}" && -d "${BASHCLI_CLI_DIR}" ]]; then
    echo "[error]: bashcli variables not properly initialized" >&2
    return
  fi

  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  fi

  if type _comp_initialize >/dev/null 2>&1 ; then
    # bash-completion >= 2.12
    _comp_initialize -s -- "$@" || return
  elif type _init_completion >/dev/null 2>&1; then
    # bash-completion < 2.12
    _init_completion -s -- "$@" || return
  else
    echo "[error]: bash-completion is not available or could not be loaded" >&2
    return
  fi

  # shellcheck source=/dev/null
  . "${BASHCLI_DIR}"/lib/all || return

  for ((index = 0; index <= cword; ++index)); do
    word=${words[index]}
    option=
    case ${word} in
      --?*)
        option=${word#--}
        option=${option%%=*}
        if [ "${BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}" ]; then
          option=${BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}
        fi
        if [[ ${index} -lt ${cword} ]]; then
          if [[ ${word} == *=* ]]; then
            option=
          else
            case ${BASHCLI_CONTEXT_OPTIONS[${option}]} in
              single|multi) ((++index)) ;;
              *) option=
            esac
          fi
        elif [[ ${word} != *=* ]]; then
          option=
        fi
        ;;
      -[^-]*)
        local options=${word#-}
        local optionsIndex
        for ((optionsIndex = 0; optionsIndex < ${#options}; ++optionsIndex)); do
          option="${options:${optionsIndex}:1}"
          if [ "${BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}" ]; then
            option=${BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}
          fi
          case ${BASHCLI_CONTEXT_OPTIONS[${option}]} in
            single|multi)
              if [[ ${optionsIndex} -eq $((${#options} - 1)) ]]; then
                ((++index))
              else
                option=
              fi
              break ;;
          esac
          option=
        done ;;
      *)
        if bashcli-command-resolve "${commandStack[@]}" "${word}"; then
          local commandDir=${REPLY}
          commandStack+=("${word}")
          bashcli-context-read "${commandDir}"
          if [ -f "${commandDir}"/completion ]; then
            # shellcheck source=/dev/null
            . "${commandDir}"/completion
          fi
        fi
    esac
  done

  if [ "${option}" ] && [ "${BASHCLI_CONTEXT_OPTION_COMPLETIONS[${option}]}" ]; then
    readarray -t completionFns <<<"${BASHCLI_CONTEXT_OPTION_COMPLETIONS[${option}]//,/$'\n'}"
  elif [ -z "${option}" ] && [ "${BASHCLI_CONTEXT_OPTION_COMPLETIONS[%parameter]}" ]; then
    readarray -t completionFns <<<"${BASHCLI_CONTEXT_OPTION_COMPLETIONS[%parameter]//,/$'n'}"
  elif [ "${option}" ]; then
    completionFns=('file')
  elif [[ "${cur}" == -* ]]; then
    for option in "${!BASHCLI_CONTEXT_OPTIONS[@]}"; do
      if [ ${#option} -gt 1 ]; then
        local suffix
        case ${BASHCLI_CONTEXT_OPTIONS[${option}]} in
          single|multi) suffix='=' ;;
          *)            suffix=' ' ;;
        esac
        BASHCLI_COMPLETIONS[--${option}${suffix}]=${BASHCLI_CONTEXT_OPTION_DESCRIPTIONS[${option}]}
      fi
    done
  else
    bashcli-command-subcommands "${commandStack[@]}"
    if [ ${#REPLY[@]} -gt 0 ]; then
      for subcommand in "${REPLY[@]}"; do
        if bashcli-command-resolve "${commandStack[@]}" "${subcommand}"; then
          local commandDir=${REPLY}
          bashcli-context-read "${REPLY}" || continue
          BASHCLI_COMPLETIONS["${subcommand} "]=${BASHCLI_CONTEXT_DESCRIPTIONS[${commandDir}]%%$'\n'*}
        fi
      done
    else
      completionFns=('file')
    fi
  fi

  completionFns=("${completionFns[@]//*/bashcli-complete-&}")
  for completionFn in "${completionFns[@]}"; do
    if declare -pf "${completionFn}" &>/dev/null; then
      "${completionFn}" "${cur}"
    else
      bashcli-log-warning "Completion function ${completionFn} not defined"
    fi
  done

  COMPREPLY=()
  # shellcheck disable=SC2016
  _comp_compgen -- -W '"${!BASHCLI_COMPLETIONS[@]}"'
  case ${COMP_TYPE} in
    9|37) ;;
    *)
      if [ ${#COMPREPLY[@]} -gt 1 ]; then
        local padding=0
        for completion in "${COMPREPLY[@]}"; do
          if [[ ${#completion} -gt ${padding} ]]; then
            padding=${#completion}
          fi
        done
        for index in "${!COMPREPLY[@]}"; do
          completion=${COMPREPLY[index]}
          printf -v completion "%-${padding}s  %s    " "${completion}" "${BASHCLI_COMPLETIONS[${completion}]}"
          COMPREPLY[index]="${completion}"
        done
      fi ;;
  esac
}

bashcli-completion-script() {
  cat <<EOF
_${BASHCLI_CLI_NAME}_complete() {
  local BASHCLI_DIR="${BASHCLI_DIR}"
  local BASHCLI_CLI_NAME="${BASHCLI_CLI_NAME}"
  local BASHCLI_CLI_DIR="${BASHCLI_CLI_DIR}"

  if ! type bashcli-completion-complete &>/dev/null; then
    . "${BASHCLI_DIR}/lib/completion" || return
  fi
  bashcli-completion-complete "\$@"
} && complete -o nospace -o default -F _${BASHCLI_CLI_NAME}_complete ${BASHCLI_CLI_NAME}
EOF
}

#!/usr/bin/env bash

# shellcheck disable=SC2215,SC2165,SC2167,SC2004,SC2059
bashcli-options-parse() {
  local _options _option _optionType _index _argument _arguments
  local _multiOptionRefPattern='__%s_ref' _multiOptionRef _multiOptionVar
  local -n _parsedOptions _parsedParameters
  local -A _multiOptionRefs=()
  local -a _multiOptionVars=()
  local _commandDir _commandStack=("${BASHCLI_COMMAND_STACK[@]}")
  local -A _subcommandOptions=()

  # Parse this functions arguments: OPTIONS-MAP PARAMETERS-ARRAY [ MULTI-OPTION-MAP ... ] -- ARGUMENTS
  for ((_index = 1; _index <= $# + 1; ++_index)); do
    if [ ${_index} -eq $(($# + 1)) ]; then
      bashcli-log-error "Option separator (--) missing"
      return 1
    fi
    _argument="${!_index}"
    if [ "${_argument}" == '--' ]; then
      shift ${_index}
      break
    fi

    case ${_index} in
      1)
        if ! declare -p "${_argument}" | grep -q "^declare -[[:alpha:]]*A"; then
          bashcli-log-error "Variable ${_argument} must be declared with the -A attribute"
          return 1
        fi
        _parsedOptions=${_argument} ;;
      2) _parsedParameters=${_argument} ;;
      *) _multiOptionVars+=("${_argument}") ;;
    esac
  done

  # Read command's context.
  if bashcli-command-resolve "${_commandStack[@]}"; then
    _commandDir=${REPLY}
    bashcli-context-read "${_commandDir}"
  fi

  # Initialize the multi-option namerefs.
  for _multiOptionVar in "${_multiOptionVars[@]}"; do
    _option=$(-bashcli-options-resolve-multivar "${_multiOptionVar}") || return 1
    _multiOptionVar=${_multiOptionVar%%=*}
    printf -v _multiOptionRef "${_multiOptionRefPattern}" "${_multiOptionVar}"
    eval "local -n ${_multiOptionRef}=${_multiOptionVar}" || return 1
    _multiOptionRefs[${_option}]=${_multiOptionRef}
  done

  # Parse the options into the provided variables.
  while [ $# -gt 0 ]; do
    case $1 in
      --help)
        bashcli-help-show "${_commandStack[@]}"
        exit 0 ;;
      -[^-]?*)
        # Split multiple concatenated options.
        _arguments=()
        for ((_index = 1; _index < ${#1}; ++_index)); do
          _option=${1:_index:1}
          if bashcli-options-resolve-alias "${_option}"; then
            _option=${REPLY}
          fi
          _optionType=${BASHCLI_CONTEXT_OPTIONS[${_option}]}
          if [ -z "${_optionType}" ]; then
            _optionType=${_subcommandOptions[${_option}]}
          fi
          if [ -z "${_optionType}" ]; then
            printf "%s\n" "${_commandStack[*]}: unrecognized option: -${_option}" >&2
            exit 1
          fi
          _arguments+=("-${_option}")
          case ${_optionType} in
            single|multi)
              _arguments+=("${1:_index + 1}")
              break ;;
          esac
        done
        shift
        set -- "${_arguments[@]}" "$@"
        continue
        ;;
      -*) _option=${1#-}
          _option=${_option#-}
          if bashcli-options-resolve-alias "${_option}"; then
            _option=${REPLY}
          fi
          if [ -n "${BASHCLI_CONTEXT_OPTIONS[${_option}]}" ]; then
            _optionType=${BASHCLI_CONTEXT_OPTIONS[${_option}]}
            case ${_optionType} in
              single|multi)
                if [ $# -lt 2 ]; then
                  printf "%s\n" "${BASHCLI_COMMAND_STACK[*]}: option requires an argument: $1" >&2
                  exit 1
                fi ;;
            esac
            case ${_optionType} in
              single)
                _parsedOptions[${_option}]=$2
                shift ;;
              multi)
                if [ -n "${_parsedOptions[${_option}]}" ]; then
                  _parsedOptions[${_option}]+=$'\n'
                fi
                _parsedOptions[${_option}]+=$2
                if [ -R "${_multiOptionRefs[${_option}]}" ]; then
                  eval "${_multiOptionRefs[${_option}]}+=(\"$2\")" || return 1
                fi
                shift ;;
              boolean)
                _parsedOptions[${_option}]=true ;;
              enum:?*)
                _parsedOptions[${_optionType#enum:}]=${_option} ;;
              *)
                bashcli-fatal "Internal error" ;;
            esac
          elif [ -n "${_subcommandOptions[${_option}]}" ]; then
            _parsedParameters+=("$1")
            case ${_subcommandOptions[${_option}]} in
              single|multi)
                if [ $# -gt 1 ]; then
                  shift
                  _parsedParameters+=("$1")
                fi ;;
            esac
          else
            printf "%s\n" "${_commandStack[*]}: unrecognized option: $1" >&2
            exit 1
          fi ;;
      *)
        if bashcli-command-resolve "${_commandStack[@]}" "$1" 2>/dev/null; then
          _commandDir=${REPLY}
          _commandStack+=("$1")
          bashcli-context-merge-options "${_commandDir}" _subcommandOptions
        fi
        _parsedParameters+=("$1")
    esac
    shift
  done
}

-bashcli-options-resolve-multivar() {
  local option step optionType

  if [[ $1 == *=* ]]; then
    option=${1#*=}
    optionType="${BASHCLI_CONTEXT_OPTIONS[${option}]}"
  else
    for step in 1 2 3 4 5; do
      case ${step} in
        1)   option=$1 ;;
        2)   option=$(bashcli-string-camel-to-kebab "$1") ;;
        3|5) option=${option%-options} ;;
        4)   option=$(bashcli-string-snake-to-kebab "$1") ;;
      esac
      if [[ -n "${option}" ]]; then
        optionType="${BASHCLI_CONTEXT_OPTIONS[${option}]}"
        if [ -n "${optionType}" ]; then
          break
        fi
      fi
    done
  fi

  case ${optionType} in
    multi)
      bashcli-log-debug "$1 -> ${option}"
      printf "%s" "${option}" ;;
    *)
      if [ -n "${optionType}" ]; then
        bashcli-log-error "Matched variable $1 with non-multi option ${option}"
      else       
        bashcli-log-error "Failed to match variable $1 with any options"
      fi
      return 1 ;;
  esac
}

bashcli-options-resolve-alias() {
  local input=$1 alias option IFS=,

  REPLY=''
  for option in "${!BASHCLI_CONTEXT_OPTIONS[@]}"; do
    for alias in ${BASHCLI_CONTEXT_OPTION_ALIASES[${option}]}; do
      if [ "${alias}" == "${input}" ] ;then
        REPLY=${option}
        break
      fi
    done
    if [ -n "${REPLY}" ]; then
      break
    fi
  done

  if [ -n "${REPLY}" ]; then
    bashcli-log-debug "${input} -> ${REPLY}"
  fi
  [ -n "${REPLY}" ]
}
